+++
date = "2019-07-09T10:18:04+09:00"
description = ""
draft = false
tags = ["ruby", "rails"]
title = "Rails 開発で意識していること 2"
updated = "2019-07-09T10:18:04+09:00"
+++

---

[my-rails-practice-1]: /posts/my-rails-practice1/

[Rails 開発で意識していること 1][my-rails-practice-1] の続きです。

- [Rails 開発で意識していること 1][my-rails-practice-1]
- Rails 開発で意識していること 2 (この記事)


前回は曖昧にしていましたが、ここでモデルに関する単語の使い分けを決めておきます。

- `ActiveRecord` - ORM & Repository 機能を実現する Rails の抽象クラス (`ActiveRecord::Base`)
- Active Record - `ActiveRecord`を継承し RDB のテーブルにマッピングされるクラス
- モデル - MVC の M

## ビジネスロジックをどう構築するか

前節で書いたプレーンなクラスを基礎とするモジュール化は、ビジネスロジックをユースケースごとに実装するのに使えそうです。
しかしながら、素の Rails にそのようなモジュールを置くためのレイヤーはありません。
Rails がベースとしている MVC の区分でいえばモデルの部分がそうなるはずですが、 Rails では基本的に「モデル == Active Record」と位置づけられるようです。
[Rails Guides][rails-guides] (v5.2) の [Active Record Basics][rails-guides-active-record-basics] を見ても以下のようにあります:

> Active Record is the M in MVC - the model - which is the layer of the system responsible for representing business data and logic.
Active Record facilitates the creation and use of business objects whose data requires persistent storage to a database.

Active Record は MVC におけるモデルにあたり、データの永続化を伴うビジネスロジックを表現するオブジェクト、とあります。
なので、これに当てはまるロジックであれば Active Record として実装すれば問題ないものの、そうではないケースはどうするのか、というのが Rails ではよく問題になります。
例えば、

- 1つのユースケースが複数の Active Record に関わる場合
- 1つの Active Record が複数のユースケースに関わる場合
- 外部サービスとの連携など永続化以外の副作用を伴う場合

などです。

こういう難点に当たると Rails がフレームワークとして未熟なのではという気もしますが、これは意図的に選択された方針ゆえの制約と言えるようです。
Rails は色んなものを密結合にして諸々の Easy さを実現しているフレームワークなので、ある程度の規模になると必要に応じてその方針に逆らいながらコードを構築する必要が出てきます (スケーラビリティを犠牲にする選択がフレームワークとしてどうなのという話はあるかもしれません)。
このあたりの認識や葛藤については、以下のスライドがすごく良くまとまっています:

[Ruby on Rails の正体と向き合い方 - Speaker Deck][rails-shotai]

[rails-shotai]: https://speakerdeck.com/yasaichi/what-is-ruby-on-rails-and-how-to-deal-with-it

また先ほど触れた Rails Guides にしても、`Models`セクションの最後には`ActiveModel`を紹介する [Active Model Basics][rails-guides-active-model-basics] という章もあります。
`ActiveModel`は、 Active Record ライクなモデル定義の仕組みを ORM とは切り離して使えるライブラリです。
なので、必ずしも「Active Record でないオブジェクトをモデルとすべからず」と謳っているわけではないのだと思います。

[rails-guides]: https://guides.rubyonrails.org/v5.2/
[rails-guides-active-record-basics]: https://guides.rubyonrails.org/active_record_basics.html
[rails-guides-active-model-basics]: https://guides.rubyonrails.org/active_model_basics.html

というわけで、 Active Record に収まらないビジネスロジックのまとめ方については大きく以下の2方向がありうると思います:

- モデル層を拡張する
    - Active Record かどうかにはこだわらず、ドメインモデルを積極的に抽出してロジックの基礎とする。
- モデル層の上に新たなレイヤーを設ける
    - ユースケースを扱うレイヤーを作りそこにロジックを置く。 Active Record はロジックの構成要素の1つになる。

後者でいう新たなレイヤーはよくサービスと名付けられます。
これらは別に相反するものでも二者択一でもなく、要件に応じて適したやり方を都度考えるのが良いはずです。
ただ後者の方向に強く傾くと、モデルとは Active Record だと割り切ってなるべく薄くしよう (ただのエンティティ的に扱おう) という風にもなります。  
実は自分は割とそうなりがちで、ユースケースはひとまずトランザクションスクリプト的にサービスとして実装してしまいます。
これはある種の設計をサボっているとも言えるかもしれません。
これがベースになると`app/models`内には (抽象クラスを除くと) エンティティ的な Active Record (+ Validation, Callback) だけが置かれ、ビジネスロジックは全部`app/services`に入ってるという感じになります。
雑かもしれませんがこれはこれでわかりやすく、最低限サービスの責務の切り分けがちゃんと出来ていれば問題なく運用できる印象です。

なのでこれまでは基本この方法で良いだろうと正直思ってたのですが、この機に[ドメインモデル貧血症][anemic-domain-model]の話や[サービスクラスを設計から逃げるために使うな][do-not-use-service-class]という記事を改めて読み返してみると、改善すべき点もあるかもしれないと思えてきています。  
例えば`ActiveRecord`に[`composed_of`][composed-of]という機能があるのも、恥ずかしながらつい最近まで知りませんでした。
これを使えば独自の値オブジェクトを使ったモデルの構築もやりやすそうですね。
この記事を書いていて、モデルの設計について再考してみたいと思うようになりました。

[do-not-use-service-class]: https://qiita.com/joker1007/items/25de535cd8bb2857a685
[anemic-domain-model]: https://martinfowler.com/bliki/AnemicDomainModel.html
[composed-of]: https://api.rubyonrails.org/classes/ActiveRecord/Aggregations/ClassMethods.html

何にせよ Rails におけるモデルやビジネスロジックの考え方・切り分け方については、実は明確に語れない状態だったという事に気づきました。  
とはいえ大事なのは「モデルかサービスか」のカテゴリ分けを頑張る事ではなく、責務や変更可能性に応じてコードを適切にグルーピングし依存を管理する点だと思うので、ひとまずは現時点で気をつけるべきだと思っている点を引き続き書いていきます。

## モデルは Entity + Repository に専念？

Active Record なモデルは RDB のテーブルと (基本) 1:1 にひも付き、そのクラスオブジェクトは DB アクセスを行う Repository として、インスタンスはレコードにマッピングされる Entity として振る舞います。
つまりは既に充分な責務を負ってるので、それ以上の責務はあんまり追加しない方が良いんじゃないかと思ってます。
ただ前述のようにそもそも Active Record じゃないモデルについてはちゃんと考えてこなかったので、タイトルには`？`をつけてます。

とりあえず Active Record には以下だけを持たせる事が多いです:

- `has_many`などの関連定義
- enum の定義
- バリデーション
- 使い回しやすいスコープ
- 状態へのアクセサメソッド

最後のやつは、例えば GitHub の Issue みたいなチケットを表すモデルがあったとして、

- そのチケットがクローズされた日付を`closed_at`として持っている
- クローズ済みかどうかの判定をリーダブルに書きたい

といった場合に作られるであろう以下のようなメソッドです:

```ruby
def closed?
  closed_at != nil
end
```

これがあれば、`!issue.closed_at.nil?`ではなく`issue.closed?`という自然な Ruby コードで状態の判定を記述できます。

しかし、ではそのチケットを実際にクローズする処理はどうでしょうか？  
単に日付をセットするだけなら`update!(closed_at: Time.current)`ですむし、
モデルがそういうインスタンスメソッドを持つのも自然ですが、実際には通知の送信や関連する他のモデルあるいはキャッシュの更新など、それ以外の副作用を伴うケースもよくあると思います。
その場合にクローズ処理をモデルに持たせるなら、一連の処理をセットにしたメソッドを作るか、`ActiveRecord`のコールバックで副作用を実行するかになると思います。
が、個人的にはどちらもあまり選択したくありません。
Active Record だとクラスのコンストラクタを使って依存を注入するやり方は使えないし、`ActiveRecord`のコールバックは他のユースケースと競合しやすく、経験的には時間が経つにつれて「特定の場合は除きたい・実行したい」という条件分岐で継ぎ接ぎされがちだからです。
のみならず、テストでActive Record のインスタンスを生成する際に、自動で走る各種コールバックが邪魔になる事もあります。
よって、モデルの状態変更以外を伴うこの手の処理は、例えロジックとしては複雑じゃなくてもサービスとして切り出す方が無難じゃないかと思っています。  
正直この辺の「モデルにどこまで持たせるか」に明確な基準は見い出せていないのですが、
とりあえずは「モデルに持たせるとテストしづらいなら切り出す」くらいで良いかもしれません。


またモデル以前に、大前提として RDB のテーブル設計をサボってはならない点は言うまでもありません。
永続化データはアプリの基盤ですから、可能な限り整合性を保ちやすい形で保存すべきモノ・コトをテーブル化し、 RDB の制約を活用してデータを守っていく事は、コードの設計にも増して重要です。

## ユースケースは個別にモジュール化する

次に、モデルとコントローラの間に位置するサービス層について考えます。  
あるモデル (Active Record) に関する処理が、何でもかんでもそのモデルクラスに詰め込まれている例をよく見ます。
これは本来なら分けるべき Active Record が1つのクラスになっているというケースもありますが、先に載せた [Ruby on Rails の正体と向き合い方][rails-shotai] にもあるように、1つのモデルがいつの間にか複数のユースケースを抱えてしまうケースも多いと感じます。
例えば同じデータでも、登録方法に Web 画面経由と CSV のアップロードによる一括登録の2種類があったり、
ページや機能ごとに条件や結果フォーマットの異なる検索処理が何種類か必要だったり。
本来は別物であるはずの複数の処理が、同じ DB のテーブルを扱っているというだけの理由で1つのモデルクラスに詰め込まれると、無関係なメソッドが同居したり、バリデーションやコールバックが条件分岐だらけになったりします。

これは辛いので、自分はよくこの手の処理を個々の独立したクラスとして実装します。
これは素の Rails にはないレイヤーなので、だいたい`app/services`のようなディレクトリを作り (`app/lib`の時もある)、そこに置いていきます。
これらのクラスは便宜的にサービスと呼び、サービスはモデルや他のサービスに依存しつつ、1つ1つのユースケースを実現する役割を担います。
でコントローラは Web レイヤーとビジネスロジックを仲介する役割を担い、基本はサービスを呼び出して処理を移譲するだけ、という感じになります。
このようなビジネスロジックを担う層を設ける事で、フレームワークとロジックを分離しやすくなり、ロジック自体も個々のユースケースに沿って独立させやすくなります。

ロジックをサービス化する際には以下を意識します:

- サービスの担う責務 (=テスト項目) を明確にする。
- 1つの責務を複数のサービスに重複して負わせない。
- 依存関係は実行時に差し替え可能にする。

これはひとえにテスタビリティとメンテナビリティを確保するためです。
ここに、前回の記事で記したようなプレーンなクラスによる実装がフィットすると考えています。
余計な仕組みを持たず、依存は全てコンストラクタで受け取るというシンプルな作りでサービスを構成出来るからです。

サービスの種類は大別すると登録・更新系 (書き込み) と検索系 (読み込み) に分かれると思いますが、特に役割に応じた分類などはせず、いずれもサービスとして置いていきます。
サービスの中間データや結果の型が欲しい時は、だいたいサービス内にクラスを定義して使います。
あるいは複数の責務に分割可能な大きめの処理なら、ファサードとして1つサービスを作り、そのネームスペース内で更に小さなサービスを複数作った上で、ファサードがそれらに依存する形で全体の機能を実現したりもします。

そして今の所は上述した責務の切り分けなどを守ればひとまず OK で、それ以上のルールはあまり作らない事が多いです。
そのくらいゆるい方が、既に雑多なクラスやミックスインを`app/services`に持つ既存プロジェクトをメンテしていく場合や、メンバーの中に奔放な人がいる場合などでも、少ない手間でビジネスロジックを守っていきやすい気がします。  
しかし、ちゃんとやるなら例えば [Hanami の Interactor][hanami-interactor] みたいに各サービスは`call`というメソッドだけを公開する、とか決める方が良さそうではあります。

[hanami-interactor]: https://guides.hanamirb.org/architecture/interactors/

## コントローラはやっぱり薄くする

コントローラはリクエスト情報からモデルまで何でも触れてしまうのでついロジックを書いてしまいがちですが、これを許すとコントローラの責務が再現なく大きくなるし、コードの共有やテストもしづらいので避けたいところです。
Rails にはコントローラをテストする仕組みも用意されているものの、これは[`ActionDispatch::IntegrationTest`][actiondispatch-integrationtest]というクラス名にもある通り結合テスト向けで、
テストの入出力はリクエスト・レスポンスの形式となり、依存のモック化も (自分が知る限りだと) 普通はしません。
そのため、コントローラにはそれ単体でテストできなくても問題ないコードのみを置くべきでしょう。
すなわち DSL 記述に徹し、ロジックはサービスクラスに移譲するのが無難です。

[actiondispatch-integrationtest]: https://api.rubyonrails.org/v5.2.3/classes/ActionDispatch/IntegrationTest.html

### アクションフィルタは最小限に

`before_action`などのフィルタは便利だし使い時はありますが、必要以上に使われているのをちらほら見かけます。
典型的には複数のアクションに共通で使う何らかのインスタンス変数をセットする処理です。

```ruby
before_action :find_issue, only: %i[show create edit update]

def find_issue
  @issue = Issue.open_by(current_user).find(params[:id])
end
```

確かにコードの共通化は出来ますが、後続のコードがフィルタ内でセットされるインスタンス変数に暗黙的に依存する事になりコードの認知負荷を上げがちです。
こういうのは共通化するにしてもフィルタではなくプライベートメソッドとして行い、インスタンス変数へのセットは各アクションでやる方が良いでしょう。

```ruby
def show
  @issue = find_issue(params[:id])
  # ...
end
```

フィルタにはユーザ認証やロギングなど、広く必要とされアクションのコードに直接影響しない処理のみを置くのが良いと思います。


### コントローラも単体テストしたい

ちょっと脱線になりますが、 Rails について考えた事の1つなので書いておきます。

前述のように Rails にはコントローラを単体テストする仕組みが用意されていないようなのですが、
個人的にはコントローラの単体テストがしたくなる事もあります。
例えば、処理の結果に応じて複数の HTTP ステータスコードや特定の HTTP ヘッダを返し分けたいとしましょう。
この時処理自体はサービスに移譲すれば済みますが、そのサービスの結果に応じてステータスコードを変えるのはコントローラの責務とする方が自然です。
すると、結果に応じたレスポンスをちゃんと返すかのテストをさくっと置いときたくなります。
コントローラにモックのサービスを渡してテストできると楽なのですが、それをシンプルにやる方法は用意されていません。
HTTP まで意識したサービスを作ってそいつが直接ステータスコードなどを生成する手もありますが、そもそもコントローラ自体が単体テスト可能であればそういう苦労は不要なのになーと思います。
実際 [Hanami の Controller][hanami-controller] (というか Action) はコンストラクタで依存を渡せるし、単体テストも可能なようです。

[hanami-controller]: https://github.com/hanami/controller

それ以外にもコントローラはたくさんの親クラスのメソッドに頼る必要があったり、結果 (ビューへのパラメータ) をインスタンス変数として表すのが基本だったりするのも、コードの可読性を下げがちで不満でした。
なので、その辺の不満を解消できる [ActionHandler](https://github.com/ryym/action_handler) という gem を作った事があります。
これを使うとコントローラと同じ機能をハンドラとして以下のように書けるので、テストがしやすいです。
必要な情報は引数として宣言すればアクセスでき、ビューへのパラメータを含む結果は全て戻り値として表現します。


```ruby
class UsersHandler # Like UsersController
  include ActionHandler::Equip

  def initialize(ranking: RankingService.new)
    @ranking = ranking
  end

  def index(params, cookies)
    puts "cookies: #{cookies}"

    users = User.order(:id).page(params[:page])
    ranks = @ranking.generate(users)

    render locals: { users: users, ranks: ranks }
  end
end
```

```ruby
# test
handler = UserHandler.new(ranking: mock_ranking_service)
result = handler.index(mock_params, mock_cookies)
expect(result[:locals]).to eq(expected_result)
```

が、現状特に実運用はしていなくて、本来コントローラだってもっと副作用を局所化した形で書けるはずだという事を確かめるために作りました。
どうしても Rails のコントローラで依存を差し替えたい場合は、使用するサービスをインスタンス変数化しておき、テスト時にはそれにモックをセットする感じかなと思っています
(あまりちゃんとやった事ないですが...)。


## テストを負債にしない

テストは大事ですがただ書けば良いというわけではありません。

### テストは落ちるためにある

例えば冒頭にフレームワークの DSL とビジネスロジックは分けて考えるべきだと述べましたが、これはテストにも言えます。
そこでも少し触れましたが、例として以下のようなモデルのバリデーション定義がある時:

```ruby
class User < ApplicationRecord
  validates :name, presence: true
end
```

「`name`が空の`User`は invalid になる」事を確かめるだけのテストは必要でしょうか？  
自分は不要だと思います。この記述が期待通りに動作するかは Rails が責任を持つ部分だからです。
そのため、この手のテストはほとんど DSL が正しく書けているかのダブルチェック的な意味しか持たないはずです。
そういうダブルチェックが全く無用だとは思いませんが、やり出すとキリがなくなります。
`User`の`validates`記述を1つずつ確かめるようなテストケースを書いても、`validates`の定義を変える度に修正されるだけのテストになるでしょう。
なのでこの例であれば、ユーザ登録などのユースケースをテストする過程でバリデーションが機能しているかを間接的に確認できれば充分ではないかと思います。

テストはバグを発見する事はできても、バグがない事を証明する事は出来ません。
なので上の例のように (仕様が変わらない限り) 落ちないテストに労力を割くのは意義が薄いと感じます。
それよりもアプリのユースケースに沿ったテストを書き、

- 将来のリファクタリングや機能改善で起きうるバグの混入を検知可能にする
- 想定される・誤った使われ方のサンプルをコードとして可視化する

ためにこそテストを残すべきではないでしょうか。

### 実装ではなくインターフェイスをテストする

これはモジュール同士がインターフェイスにのみ依存すべきなのと同じ理由です。
実装の詳細をなぞるだけのテストは、実装をダブルチェックしているだけのようなものでしょう。
そうではなく入力と欲しい出力のペアだけを用意して、中身の実装に関わらず期待する結果が得られる事を担保しておくのがわかりやすいです。

### DB アクセスはどうする？

DB アクセスは重い処理なので、DB を使わずにテストできるならしない方が良いかもしれません。
例えば DB 上にある何らかのデータを集計・保存するモジュールをテストしたい場合、データの取得、集計、保存をそれぞれ別のメソッドにしておけば、メインの集計処理に関しては DB へのアクセスなしでテストできます。
テスト用のモデルインスタンスを事前に作成してそれを渡し、返ってきた結果が期待する内容に一致しているかを調べればいいからです。
その上で DB アクセス処理を含むテストも簡単に用意しておけば、モジュール全体の動作も確認出来ます。

逆に検索条件を受け取って DB からデータをロードするような検索系のモジュールでは、頑張って DB アクセスをモック化しても意義は薄いと思います。
やるならせいぜい期待通りにモデルのスコープが呼ばれるかを確認するくらいでしょうが、これはほとんど実装の詳細をテストしているに過ぎません。
こういう場合は素直に DB 上にモックデータを登録し、期待する結果が得られるかを確かめるテストを書くしかないと思います。

とはいえ、この辺は ActiveRecord を使う上で悩ましい点だと感じます。
クラスを Repository 的なインターフェイスとして捉えるには、スコープはあまりにも実装によりすぎているというか、全てをモック化してもあまり有意義なテストになるとは感じません。
そのためモジュールのテストで DB アクセスをモック化したい場合は割と迷います。
ちゃんとやるなら DB アクセス処理だけを別の依存として切り出す事もあるし、
DB アクセスの部分をメソッドにまとめておき、それをテスト時には上書きしてモック化するという動的な方法を取る事もあります。

またモデルのスコープをどのくらいテストすべきかもよく迷います。
例えば以下のような簡単なスコープならほとんど DSL だけなので、普段はあまりテストまで書きません。

```ruby
scope :closed, lambda {
  where(status: %i[closed merged])
}
```

またテストするにしても、実際に DB アクセスをするのではなく、`to_sql`で期待する SQL 文字列が作られるかだけを確かめる方法もあります。
自分は当初この方法はあまり好きではありませんでした。
Rails が生成する生の SQL をチェックする事になるし、それはスコープを修正する度に落ちるテストであり、やはりダブルチェックくらいの意義しかないからです。
ただ JavaScript の [Snapshot Testing][snapshot-testing] を知った後では、この SQL 文字列のテストも似たようなものだと気づき、方法の1つとしてはありだと考えるようにもなりました。
単純なスコープならそもそも不要でしょうが、多少複雑で ActiveRecord の DSL によるクエリが期待通りの SQL になるかを確認したい場合は、こういうテストを置いといて修正の度に強制的に確認するのも手だと思います。

[snapshot-testing]: https://jestjs.io/docs/en/22.x/snapshot-testing

## DB マイグレーションは冪等に

DB の変更履歴をコードとして管理できるマイグレーション機能はとても便利です。
そしてマイグレーションはその性質上、可能な限り「いつ」「どこで」「何回」実行されても同じように動作する事が理想です。
例えばそのマイグレーションを作った当人の開発環境でしか動かない、作った時は動いたけど半年後に実行したらエラーになる、といったマイグレーションばかりでは、せっかくの便利さも半減します。
そうならないためにはいくつかの点に気をつけます。

なおこの点については他にも色んなところで書かれています。
いくつかの記事にリンクを貼ってくれている以下の記事を参考としておきます:  
<https://qiita.com/snaka/items/017cddd1a647d161cabd>

### マイグレーション内でモデルを使わない

マイグレーション内では基本的に DSL 以外の Ruby コードを使うべきではありません。
これは油断するとやってしまいがちですが、例えば以下です:

```ruby
def change
  create_table :preferences do |t|
    t.integer :theme, null: false, default: Preferences.themes[:light]
    # ...
  end
end
```
```ruby
class Preference < ApplicationRecord
  # ...
  enum theme: %i[light dark sepia]
  # ...
end
```

enum なカラムを持つ`preferences`というテーブルを作成するマイグレーションで、そのカラムのデフォルト値をモデルの enum 定義を使って指定しています。
これは一見良いプラクティスのように思えます。
ここでいう`light`などの enum 値が、 DB 上で実際にどんな値にマッピングされるかを意識せずにデフォルト値を記述できるからです。
しかし、マイグレーションはその用途上、作られてから何年も後に実行される可能性がある事を忘れるべきではありません。

このマイグレーションは作った時には問題なく動作するでしょう。
しかしそれから何年か経ったら事情は変わりえます。
もし後々`preferences`テーブルが削除されたら、それに伴い`Preference`クラスもなくなるはずです。
ところがそうなった場合でも、この`preferences`テーブルを作るマイグレーションファイルは依然として残り続け、どこかで実行される可能性があります。
となるともし`preferences`テーブルが削除された後に新しく開発メンバーが加わり、そのメンバーが何らかの事情でこのマイグレーションファイルを走らせるとどうなるでしょう？  
その時点のコードベースには`Preference`モデルは存在しないはずですから、このマイグレーションはエラーになってしまいます。
するとその原因調査や修正に余計な手間が発生する事になります。

まあ実際には新たに DB 環境を作る場合は`db:schema:load`でスキーマファイルを読み込むでしょうから、実は過去のマイグレーションを走らせるタイミングってそれ程無いとは思います。
しかしそれでも、マイグレーションファイルが仕組み的に将来のどこでも実行される可能性を持っている以上は、それを配慮した作り方にせざるを得ないと思います。

というわけで、自分がこの例のようなマイグレーションを書くなら、デフォルト値には素直に対応する数値を書きます。

```ruby
t.integer :theme, null: false, default: 0
```

マジックナンバー感もあって気持ち悪い気はしますが、上述した考慮を踏まえるならこちらの方がマシだと思っています。
特に enum であれば、デフォルト値となる値を列挙の先頭に置くルールにしておけば、
どんな enum であっても`default: 0`という記述に統一できてよりマシかもしれません。

ただこういった配慮が必要になってしまう時点で、そもそもマイグレーションという履歴管理の仕方自体に問題があるとも考えられます。
実際、過去のマイグレーションがずっと残るのはコード管理の面でも不便な事があります。
例えばプロジェクトのコード規約が変わった時、過去のマイグレーションファイルにも適用すべきか、しないならリンタやフォーマッタの挙動をどうするか、ある時期より前のマイグレーションファイルだけ無視するような設定を入れるか、あるいはマイグレーションファイル全体を対象外としてしまうか...などと考える事が増えます。
そうなるくらいならマイグレーションという考え方自体を見直し、[Ridgepole][ridgepole] のように過去のマイグレーションファイルを必要としないやり方の方が良いのかもしれません。
まだ試してみた事はないのですが。

[ridgepole]: https://github.com/winebarrel/ridgepole

### データの変更を含める時は慎重に

これも前節の話に似ていますが、安易にデータの追加・更新・削除をマイグレーションに含めてしまうと、実行する環境やタイミングによって結果が変わってしまうケースがあります。
他にも下記のような懸念点があるので、やるならそれらを加味した上で問題ないかを判断するのが良さそうです:

- 決まった値のレコードを追加するようなケースだと、既存のデータ次第でユニーク成約や外部キー制約への違反によりマイグレーションが失敗する可能性がある。
- サーバへのデプロイ時に自動でマイグレーションを実行している場合は、データ更新に時間がかかるとデプロイ時間がのびてしまう。
- `db:schema:load`で DB を作る場合はデータ構造の定義のみが反映されるので、`db:migrate`がデータ操作まで含んでいると両者の実行結果にずれが出る。

### 互換性を保つマイグレーションを行う

これはマイグレーション単体ではなくコードベース全体の問題ですが、ロードバランシングを行っている本番環境などで複数のサーバ (正確には Rails アプリ) が同一の DB を参照している場合は注意が必要です。
マイグレーションによる DB の更新は一度だけ走るのに対し、サーバ上のソースコードの更新はサーバごとに行われる事になります。
するとサーバによっては「DB はマイグレーション実行後の状態だけどサーバ上のソースコードはマイグレーション実行前の状態」になる時間が生じうる事になるので、その間も問題なく動作するようなマイグレーションの仕方をする必要があります。
これも詳細はリンクを貼るにとどめます:

<https://github.com/elafarge/blog-articles/blob/master/01-no-downtime-migrations/zero-downtime-database-migrations.md>

とはいえ特に小・中規模のアプリだと、常にユーザがアクセスしているわけでもない機能の修正であれば、ほんの数分くらい互換性のない状態になっても問題ないケースは全然ありえます。
なので、必要に応じて意識すれば良さそうです。

## その他の Tips

以上で大体は書けたので、後は細かな考慮事項をメモしておきます。

## RuboCop は大いに活用する

インデントなどのフォーマットが意味もなくバラバラなコードは読みづらいと思うので、自分はだいたい [RuboCop][rubocop] を導入します。
ただ RuboCop のデフォルトルールには割とアグレッシブなものも多いので、あまり RuboCop を使いたくないという声もちらほら聞きます。
しかし設定は好きなようにカスタマイズ出来るし、基本的なフォーマットを自動で統一できるのはとても便利だと思うので、自分は不要だと思うルールは積極的に無効にしつつ使っています。  
いつも使う代表的なルールをいくつか挙げると:

- インデントやスペーシングの統一
- クォートの統一
- 末尾カンマの強制適用 or 排除
- 未使用変数の発見

などがあります。
ただ「どこまで統一したいと思うか」は確かに人によりそうで、例えば`n > 0`と`n.positive?`はどちらかに統一しようという[`Style/NumericPredicate`][rubocop-style-numeric-predicate]のようなルールもあるのですが、個人的にはそのくらいなら状況に応じてより読みやすそうな方を使えば良いように感じます。
しかしインデントの統一にはこだわるのになぜこちらにはこだわらないのかと言われるとあまりハッキリした答えはなく、ルールの数だけ bikeshed を引き起こしそうな面倒さはどうしてもあります。

[rubocop]: https://github.com/rubocop-hq/rubocop

[rubocop-style-numeric-predicate]: https://github.com/rubocop-hq/rubocop/blob/master/manual/cops_style.md#stylenumericpredicate

というわけで逆に普段使わないのは、

- 個人的に統一の必要性を感じないもの (主観性強い)
- メソッドの最大行数など各種メトリクス系

あたりです。
チーム開発の場合は種類が違うこだわりを持つ人がいると衝突するかもしれませんが、自分はとにかく統一されてる事重視なので、強い希望を持つ人がいるならその人の好みに合わせます。
逆に折り合いがつかなかったり、ルールの多さにストレスを感じる人もいるなら、全員が納得できるルールだけ使うのが良いでしょう。

メトリクスは1行の最大文字数だけ使いますが、クラスやメソッドの行数や複雑度 (ABCサイズなど) は使わないか、閾値をかなり高めに設定します。
デフォルトの閾値を超えるかどうかとコードの読みやすさは必ずしも相関しないと感じる事が割とあったので、
固定の閾値を設ける意義はあまり無いかなと思っています。

## テーブル定義の`timestamp`は前の方がいい？

ActiveRecord が自動でセットしてくれる`created_at`, `updated_at`というタイムスタンプカラムは、大体一番後ろのカラムとして定義されると思います。

```ruby
create_table :users do |t|
  t.string :name, null: false
  t.integer :age, null: false

  t.timestamps
end
```

ただ、最近これらのカラムは先頭に置いとく方が便利な気がしています。
その方が将来カラムを追加したくなった時に、カラムの追加位置を気にせずに済むからです。
例えば GUI クライアントなどで DB に直接アクセスして中身を確認する時、大抵はタイムスタンプも合わせて見たいし、後からカラムがタイムスタンプの後ろに追加されていると、`SELECT *`した時にパット見でタイムスタンプを見つけにくいです。
MySQL なら`after`でカラムの追加位置を指定できますが、指定せずに済むならその方が楽です。  
この規約を設けるとどのテーブルも共通して`id`, `created_at`, `updated_at`の3つからカラム定義が始まる形になり、何となくきれいではと思います。
が、実際に業務で試した事はまだありません。

## メソッド修飾子をステートレスにする？

Ruby には`private`や`protected`といったメソッド修飾子の書き方がいくつかありますが、メジャーなのは以下のように複数のメソッドにまとめて適用する方法だと思います:

```ruby
def SomeController
  # public methods
  def index
    some_index_logic
  end

  def show
    some_show_logic
  end

  private

  # private methods
  def some_index_logic
    # ...
  end

  def some_show_logic
    # ...
  end
end
```

自分も普段はこの書き方ですが、実は個々のメソッドにインラインで記述するスタイルで統一しておく方がメリットは大きいような気がしています。

```ruby
def SomeController
  def index
    some_index_logic
  end

  private def some_index_logic
    # ...
  end

  def show
    some_show_logic
  end

  private def some_show_logic
    # ...
  end
end
```

これなら「公開されているか」に関係なく関連するメソッド同士を近くにおけるし、たとえ将来巨大なクラスに成り果ててしまってもスクロール中「どこからが private だっけ？」とならずに済むからです。
とはいえ、こちらも実際に業務で試した事はありません。

## まとめ

まだ書き忘れてる事もありそうですが、とりあえずこの辺にしておきます。
主にコードのメンテナビリティについて意識する事を色々書きましたが、そもそもコードはまず正しく動く事が大前提というのも忘れてはいけないなと思います。
どんなに汚くて手をつけにくいコードでも正しく動いてるなら偉いし、逆にそれをないがしろにしたままコードや設計の良し悪しを議論するのは滑稽です。
ただこれらは別に相反するものではなく、むしろ複雑なユースケースであるほど、真っ当に設計する事が正しく動かすためには有効であるはずだとも思います。
コードは書かれた瞬間から絶えず読まれ修正されていくわけで、それがしやすいほど「正しく動く」の定義の変化に柔軟に対応していけるはずだからです。

参考: [Is High Quality Software Worth the Cost?](https://martinfowler.com/articles/is-quality-worth-cost.html)

あとは書いていて、 Rails のレールに収まらない諸々のワークアラウンドをフレームワーク化すると [Hanami][hanami] に行き着く気がしました。
まだ触ったことはないのですが、機会があれば試してみたいです。
無論 Hanami が Rails の上位互換となるわけはないでしょうから、どんなトレードオフがあるのかを知りたいです。
あるいはどうせ自由に選べるならそもそも静的型付け言語にしたい気もしますが、なんだかんだ言っても`ActiveRecord`の便利さは日々実感します。
何を使うにしても、引き続き試行錯誤しながらコードを書いていきたいです。



[hanami]: https://hanamirb.org/

