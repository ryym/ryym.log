+++
date = "2019-07-09T10:18:04+09:00"
description = ""
draft = false
tags = ["ruby", "rails"]
title = "Rails 開発で意識していること 2 - 詳細編"
updated = "2019-07-09T10:18:04+09:00"
+++

---

<https://qiita.com/joker1007/items/25de535cd8bb2857a685>

↑ 書き始める前にちょっと探して見つからなかったけど、偶然見つけた。
個人的には`app/models`内には ActiveRecord に紐づく entity だけ置きたくなっちゃうけど、
それは間違ってるという感じか。
やはり独自レイヤーとモデル (というか ActiveRecord?) あたりの話は難しい。
実際うまく実践できてない面も多そうだけど、教えてくれる人がいないと中々気づきづらい。
「この方法ですべき！」みたいな書き方じゃなくて、「だいたいこんな感じだけど微妙な面ある」みたいな書き方の方がいいかも。

- だいたいトランザクションスクリプトでやっちゃう
    - 中規模だとちゃんと見張ってれば責務の重複とかあまり起きない
        - 単にコードが似てるだけでは共通化する理由にならない
    - `models`に置くべきか`services`に置くべきか、ちゃんと判断する苦労を避けてる面がある
        - 正直 activerecord だけ`models`で今の所問題ない。規模や扱うドメインの複雑さによってはこれだと問題あるのかも。。
    - `services` (`lib`?) に詰め込まれる例
        - 検索処理
        - 集計処理
            - 例え1つのテーブルだけの集計でも分けちゃう。ただクラスは分けるにしても`models`内でそばにある方がわかりやすいのは確かか
        - 登録処理
            - ネストして Form 置いてもいいかも
        - API クライアントとか。たぶん本来はトップレベルの`lib`に置くべきかも。
    - ファイルは名前がちゃんとしてれば ctrl+p で探せちゃうので、あまり気にしなくていい気もしてる
        - でもディレクトリ構造を眺めるケースだってたくさんあるか。。
- モデル == ActiveRecord な前提でやってきちゃった
    - まず RDB レベルでちゃんと整合性取るのは意識してる
    - `composed_of`とか知らなかった。これ使えばもっとリッチにできそう。
    - 単純にテスタビリティの問題で activerecord にロジック置きたくないのはある
    - まずユースケースを基点にして、その中で結果をまとめるクラス作ったりとかはある

---

[my-rails-practice-1]: /posts/my-rails-practice1/

[Rails 開発で意識していること 1][my-rails-practice-1] の続きです。
詳細というか、 前回の記事で書いたような方針を踏まえつつ、 Rails の各レイヤーでどんな事に気をつけているかを書いておきます。
まずはビジネスロジックを置く独自レイヤーについてです。

## ビジネスロジック用の独自レイヤーを設ける

いきなり Rails のレールを外れる事になりますが、モデルにはまらないビジネスロジックを置くレイヤーを作ります。
よほど単純な CRUD で完結するアプリでもない限り、何かしらこの手のレイヤーが必要になると思います。
ただレイヤーの捉え方や運用方法には色んな流儀がありそうです。  
Rails は意図的に色んなものを密結合にして諸々の Easy さを実現しているフレームワークなので、
必要に応じてその方針に逆らいながら、ビジネスロジック部分を疎結合な形で切り出していく事になります。
このあたりの認識や葛藤については、以下のスライドがすごく良くまとまっています:

[Ruby on Rails の正体と向き合い方 - Speaker Deck](https://speakerdeck.com/yasaichi/what-is-ruby-on-rails-and-how-to-deal-with-it)

素の Rails では大体モデルがユースケースの単位となるので、ロジックもモデルが持つ事になるでしょう。
しかしこのスライドにもあるように、アプリが大きくなっていくと1つのモデルがいつの間にか複数のユースケースを担っていたりします。
例えば同じデータでも、登録方法に Web 画面経由と CSV のアップロードによる一括登録の2種類があったり、
ページや機能ごとに条件や結果フォーマットの異なる検索処理が何種類か必要だったり。
こういう実は関連性の薄い複数の機能が、同じモデル (というか DB のテーブル) を扱っているというだけの理由で1つのモデルクラスに詰め込まれている事があります。
しかし実際には同じクラスに置くメリットはあまりないはずです。かといってロジックをコントローラに移すとテストやコードの共有がしづらくなります。  
そこで必要になるのが、モデルともコントローラとも異なる独自のレイヤーです。
自分もやはりこのパターンを使っていて、いつも`app/lib`とか`app/services`のようなディレクトリを設け、
そこにクラスを追加していきます。これらのクラスは便宜的にサービスと呼んでおり、
サービスはモデルや他のサービスに依存しつつ、1つ1つのユースケースを実現する役割を担います。
でコントローラは Web レイヤーとビジネスロジックを仲介する役割を担い、基本はサービスを呼び出して処理を移譲するだけ、という感じになります。

このようなビジネスロジックを担う層を設ける事で、フレームワークとロジックを分離しやすくなり、ロジック自体も個々のユースケースに沿って独立させやすくなります。
後はこれらをどんな風に実装するかです。

### 実装はプレーンなクラスで

ロジックをサービス化する際には以下を意識します:

- サービスの担う責務 (=テスト項目) を明確にする。
- 1つの責務を複数のサービスに重複して負わせない。
- 依存関係は実行時に差し替え可能にする。

これはひとえにテスタビリティとメンテナビリティを確保するためです。
ここで、前回の記事で記したようなプレーンなクラスによる実装がフィットすると考えています。
そしてこの辺さえ守れれば良いという方針で、実装における規約はあえて少なめにしたりします:

- ミックスインや module function ではなくクラスとして実装する。
- 依存関係はコンストラクタで受け取る。

ちゃんとやるなら [Hanami の Interactor][hanami-interactor] みたいに各サービスは`call`というメソッドだけを公開する、とか決めても良さそうですが、特に決めない事が多いです。
ひとまずビジネスロジックに関わるものは何でも`app/lib`あるいは`app/services`に置いてしまい、多くなってきたらその中でドメインごとにサブディレクトリを切る程度です。
中々に雑ですが、中規模なアプリだとこのくらいでも割と問題ない印象です。
特に既に雑多なクラスやミックスインを`app/services`に持つような既存プロジェクトをメンテしていく場合や、メンバーの中に奔放な人がいる場合などは、このくらいゆるい方がビジネスロジック層を守っていきやすい、というのもあります。

[hanami-interactor]: https://guides.hanamirb.org/architecture/interactors/

## モデルは Entity + Repository に専念

ActiveRecord を継承する Rails のモデルは DB のテーブルと (基本) 1:1 にひも付き、
そのクラスは DB アクセスを行う Repository として、インスタンスはレコードにマッピングされる Entity として振る舞います。
つまりは既に充分な責務を負ってるので、それ以上の責務はあんまり追加しない方が良いんじゃないかと思ってます。
そのため、モデルには基本的に以下だけを持たせたいです:

- 関連定義 (`has_many`, `belongs_to`など)
- enum カラムの定義
- カラムのバリデーション
- 使い回しやすいスコープ
- 状態へのアクセサメソッド

最後のやつは、例えば GitHub の Issue みたいなチケットを表すモデルがあったとして、

- そのチケットがクローズされた日付を`closed_at`として持っている
- クローズ済みかどうかの判定をリーダブルに書きたい

といった場合に作られるであろう以下のようなメソッドです:

```ruby
def closed?
  closed_at != nil
end
```

これがあれば、`!issue.closed_at.nil?`ではなく`issue.closed?`という自然な Ruby コードで状態の判定を記述できます。

しかし、ではそのチケットを実際にクローズする処理はどうでしょうか？  
単に日付をセットするだけなら`update!(closed_at: Time.current)`ですむし、
モデルがそういうインスタンスメソッドを持つのも自然ですが、実際には通知の送信や関連する他のモデルあるいはキャッシュの更新など、それ以外の副作用を伴うケースもよくあると思います。
その場合にクローズ処理をモデルに持たせるなら、一連の処理をセットにしたメソッドを作るか、
ActiveRecord のコールバックで副作用を実行するかになると思います。
が、個人的にはどちらもあまり選択したくありません。
モデルはプレーンなオブジェクトではないから、前述したサービスのようにクラスのコンストラクタを使って依存を注入するやり方は使えないし、 ActiveRecord のコールバックは他のユースケースと競合しやすく、経験的には時間が経つにつれて「特定の場合は除きたい・実行したい」という条件分岐で継ぎ接ぎされがちだからです。
のみならず、テストでモデルのインスタンスを生成する際に、自動で走る各種コールバックが邪魔になる事も少なくありません。
というわけで、モデルの状態変更以外を伴うこの手の処理は、例えロジックとしては複雑じゃなくてもサービスとして切り出す方が無難じゃないかと思っています。

正直この辺の「モデルにどこまで持たせるか」に明確な基準は見い出せていないのですが、
とりあえずは「モデルに持たせるとテストしづらいなら切り出す」くらいで良いかもしれません。


> ### ドメインモデル貧血症？

> (よくわからず disってるみたいにも見えるのでない方がいいかも)

> ところで、これを書いていてふと[ドメインモデル貧血症][anemic-domain-model]の話を思い出しました。
> モデルの責務を薄くしようとする方針は、このアンチパターンに当てはまるのでしょうか？
> DDD に詳しくないので何とも言えないですが、
> 個人的にユースケースはオブジェクトよりも関数として切り分ける方がシンプルになりやすい (特にテストがしやすい) と感じていて、
> その関数の操作対象 (目的語) となるオブジェクトはせいぜいデータとそのアクセサメソッドを持ってるくらいで良いのではないかと感じる事があります。
> 今回の例もそれで、ただ Ruby では関数がファーストクラスな存在ではないため、サービスクラスに似たような役割を持たせている感覚です。

[anemic-domain-model]: https://martinfowler.com/bliki/AnemicDomainModel.html

### `composed_of`使ってみたい

ActiveRecord の[`composed_of`][composed-of]という機能を使うとカラムを独自のオブジェクトにマッピング出来るので、モデルの表現力がぐっと増しそうです。
しかし恥ずかしながらつい最近までこの機能を知らなかったので、使った事がありません。
そのうち使ってみたいです。

[composed-of]: https://api.rubyonrails.org/classes/ActiveRecord/Aggregations/ClassMethods.html

## コントローラはやっぱり薄くする

コントローラはリクエスト情報からモデルまで何でも触れてしまうのでついロジックを書いてしまいがちですが、コードのテスタビリティを意識するなら避けたいところです。
Rails にはコントローラをテストする仕組みも用意されているものの、これは[`ActionDispatch::IntegrationTest`][actiondispatch-integrationtest]というクラス名にもある通り結合テスト向けで、
テストの入出力は HTTP 経由で行われ、依存のモック化も (自分が知る限りだと) 普通はしません。
そのため、コントローラにはそれ単体でテストできなくても問題ないコードのみを置くべきでしょう。
すなわちリクエスト・レスポンス周りの DSL 記述に徹し、ロジックはサービスクラスに移譲するのが無難です。

[actiondispatch-integrationtest]: https://api.rubyonrails.org/v5.2.3/classes/ActionDispatch/IntegrationTest.html

### アクションフィルタは最小限に

`before_action`などのフィルタは便利だし使い時はありますが、必要以上に使われているのをちらほら見かけます。
典型的には複数のアクションに共通で使う何らかのインスタンス変数をセットする処理です。

```ruby
before_action :find_issue, only: %i[show create edit update]

def find_issue
  @issue = Issue.open_by(current_user).find(params[:id])
end
```

確かにコードの共通化は出来ますが、後続のコードがフィルタ内でセットされるインスタンス変数に暗黙的に依存する事になりコードの認知負荷を上げがちです。
こういうのは共通化するにしてもフィルタではなくプライベートメソッドとして行い、インスタンス変数へのセットは各アクションでやる方が良いでしょう。

```ruby
def show
  @issue = find_issue(params[:id])
  # ...
end
```

フィルタにはユーザ認証やロギングなど、広く必要とされアクションのコードに直接影響しない処理のみを置くのが良いと思います。


### コントローラも単体テストしたい

ちょっと脱線になりますが、 Rails について考えた事の1つなので書いておきます。

前述のように Rails にはコントローラを単体テストする仕組みが用意されていないようなのですが、
個人的にはコントローラの単体テストがしたくなる事もあります。
例えば、処理の結果に応じて複数の HTTP ステータスコードを返し分けたいとしましょう。
この時処理自体はサービスに移譲すれば済みますが、そのサービスの結果に応じてステータスコードを変えるのはコントローラの責務とする方が自然です。
すると、結果に応じたコードをちゃんと返すかのテストをさくっと置いときたくなります。
コントローラにモックのサービスを渡してテストできると楽なのですが、それをシンプルにやる方法は用意されていません。
HTTP まで意識したサービスを作ってそいつが直接ステータスコードを生成する手もありますが、そもそもコントローラ自体が単体テスト可能であればそういう苦労は不要なのになーと思います。
実際 [Hanami の Controller][hanami-controller] (というか Action) はコンストラクタで依存を渡せるし、単体テストも可能なようです。

[hanami-controller]: https://github.com/hanami/controller

それ以外にもコントローラはたくさんの親クラスのメソッドに頼る必要があったり、結果 (ビューへのパラメータ) をインスタンス変数として表すのが基本だったりするのも、コードの可読性を下げがちで不満でした。
なので、その辺の不満を解消できる [ActionHandler](https://github.com/ryym/action_handler) という gem を作った事があります。
これを使うとコントローラと同じ機能をハンドラとして以下のように書けるので、テストがしやすいです。
必要な情報は引数として宣言すればアクセスでき、ビューへのパラメータを含む結果は全て戻り値として表現します。


```ruby
class UsersHandler # Like UsersController
  include ActionHandler::Equip

  def initialize(ranking: RankingService.new)
    @ranking = ranking
  end

  def index(params, cookies)
    puts "cookies: #{cookies}"

    users = User.order(:id).page(params[:page])
    ranks = @ranking.generate(users)

    render locals: { users: users, ranks: ranks }
  end
end
```

```ruby
# test
handler = UserHandler.new(ranking: mock_ranking_service)
result = handler.index(mock_params, mock_cookies)
expect(result[:locals]).to eq(expected_result)
```

が、現状特に実運用はしていなくて、本来コントローラだってもっと副作用を局所化した形で書けるはずだという事を確かめるために作りました。
どうしても Rails のコントローラで依存を差し替えたい場合は、仕方ないので使用するサービスをインスタンス変数化しておき、テスト時にはそれにモックをセットするしかないかなと思っています
(あまりちゃんとやった事ないですが...)。


## テストを負債にしない

テストは大事ですがただ書けば良いというわけではありません。

### テストは落ちるためにある

例えば冒頭にフレームワークの DSL とビジネスロジックは分けて考えるべきだと述べましたが、これはテストにも言えます。
そこでも少し振れましたが、例として以下のようなモデルのバリデーション定義がある時:

```ruby
class User < ApplicationRecord
  validates :name, presence: true
end
```

「`name`が空の`User`は invalid になる」事を確かめるだけのテストは必要でしょうか？  
自分は不要だと思います。この記述が期待通りに動作するかは Rails が責任を持つ部分だからです。
そのため、この手のテストはほとんど DSL が正しく書けているかのダブルチェック的な意味しか持たないはずです。
そういうダブルチェックが全く無用だとは思いませんが、やり出すとキリがなくなります。
`User`の`validates`記述を1つずつ確かめるようなテストケースを書いても、`validates`の定義を変える度に修正されるだけのテストになるでしょう。
なのでこの例であれば、ユーザ登録などのユースケースをテストする過程でバリデーションが機能しているかを間接的に確認できれば充分ではないかと思います。

テストはバグを発見する事はできても、バグがない事を証明する事は出来ません。
なので上の例のように (仕様が変わらない限り) 落ちないテストに労力を割くのは意義が薄いと感じます。
それよりもアプリのユースケースに沿ったテストを書き、

- 将来のリファクタリングや機能改善で起きうるバグの混入を検知可能にする
- 想定される使われ方をコードとして可視化する

ためにこそテストを残すべきではないでしょうか。

### 実装ではなくインターフェイスをテストする

これはモジュール同士がインターフェイスにのみ依存すべきなのと同じ理由です。
実装の詳細をなぞるだけのテストは、実装をダブルチェックしているだけのようなものでしょう。
そうではなく入力と欲しい出力のペアだけを用意して、中身の実装に関わらず期待する結果が得られる事を担保しておくのが良いです。

### DB アクセスはどうする？

DB アクセスは重い処理なので、DB を使わずにテストできるならしない方が良いと思います。

例えば DB 上にある何らかのデータを集計・保存するモジュールをテストしたい場合、データの取得、集計、保存をそれぞれ別のメソッドにしておけば、メインの集計処理に関しては DB へのアクセスなしでテストできます。
テスト用のモデルインスタンスを事前に作成してそれを渡し、返ってきた結果が期待する内容に一致しているかを調べればいいからです。
その上で DB アクセス処理を含むテストも簡単に用意しておけば、モジュール全体の動作も確認出来ます。

逆に検索条件を受け取って DB からデータをロードするような検索系のモジュールでは、頑張って DB アクセスをモック化しても意義は薄いと思います。
やるならせいぜい期待通りにモデルのスコープが呼ばれるかを確認するくらいでしょうが、これはほとんど実装の詳細をテストしているに過ぎません。
こういう場合は素直に DB 上にモックデータを登録し、期待する結果が得られるかを確かめるテストを書くしかないと思います。

とはいえ、この辺は ActiveRecord を使う上で悩ましい点だと感じます。
クラスを Repository 的なインターフェイスとして捉えるには、スコープはあまりにも実装によりすぎているというか、全てをモック化してもあまり有意義なテストになるとは感じません。
そのためモジュールのテストで DB アクセスをモック化したい場合は割と迷います。
ちゃんとやるなら DB アクセス処理だけを別の依存として切り出す事もあるし、
DB アクセスの部分をメソッドにまとめておき、それをテスト時には上書きしてモック化するという動的な方法を取る事もあります。

またモデルのスコープをどのくらいテストすべきかもよく迷います。
例えば以下のような簡単なスコープならほとんど DSL だけなので、普段はあまりテストまで書きません。

```ruby
scope :closed, lambda {
  where(status: %i[closed merged])
}
```

またテストするにしても、実際に DB アクセスをするのではなく、`to_sql`で期待する SQL 文字列が作られるかだけを確かめる方法もあります。
自分は当初この方法はあまり好きではありませんでした。
Rails が生成する生の SQL をチェックする事になるし、それはスコープを修正する度に落ちるテストであり、やはりダブルチェックくらいの意義しかないからです。
ただ JavaScript の [Snapshot Testing][snapshot-testing] を知った後では、この SQL 文字列のテストも似たようなものだと気づき、方法の1つとしてはありだと考えるようにもなりました。
単純なスコープならそもそも不要でしょうが、多少複雑で ActiveRecord の DSL によるクエリが期待通りの SQL になるかを確認したい場合は、こういうテストを置いといて修正の度に強制的に確認するのも手だと思います。

[snapshot-testing]: https://jestjs.io/docs/en/22.x/snapshot-testing

## DB マイグレーションは冪等に

DB の変更履歴をコードとして管理できるマイグレーション機能はとても便利です。
そしてマイグレーションはその性質上、可能な限り「いつ」「どこで」「何回」実行されても同じように動作する事が理想です。
例えばそのマイグレーションを作った当人の開発環境でしか動かない、作った時は動いたけど半年後に実行したらエラーになる、といったマイグレーションばかりでは、せっかくの便利さも半減します。
そうならないためにはいくつかの点に気をつけます。

なおこの点については他にも色んなところで書かれています。
いくつかの記事にリンクを貼ってくれている以下の記事を参考としておきます:  
<https://qiita.com/snaka/items/017cddd1a647d161cabd>

### マイグレーション内でモデルを使わない

マイグレーション内では基本的に DSL 以外の Ruby コードを使うべきではありません。
これは油断するとやってしまいがちですが、例えば以下です:

```ruby
def change
  create_table :preferences do |t|
    t.integer :theme, null: false, default: Preferences.themes[:light]
    # ...
  end
end
```
```ruby
class Preference < ApplicationRecord
  # ...
  enum theme: %i[light dark sepia]
  # ...
end
```

enum なカラムを持つ`preferences`というテーブルを作成するマイグレーションで、そのカラムのデフォルト値をモデルの enum 定義を使って指定しています。
これは一見良いプラクティスのように思えます。
ここでいう`light`などの enum 値が、 DB 上で実際にどんな値にマッピングされるかを意識せずにデフォルト値を記述できるからです。
しかし、マイグレーションはその用途上、作られてから何年も後に実行される可能性がある事を忘れるべきではありません。

このマイグレーションは作った時には問題なく動作するでしょう。
しかしそれから何年か経ったら事情は変わりえます。
`light`が`normal`にリネームされるかもしれません。
あるいは`preferences`テーブル自体が削除されるかもしれません。
ところがそうなった場合でも、この`preferences`テーブルを作るマイグレーションファイルは依然として残り続け、どこかで実行される可能性があります。
リネームくらいなら過去のマイグレーションを修正しても良いですが、テーブルが削除されたからといってマイグレーションファイルまで削除するわけにはいかないでしょう。
となるともし`preferences`テーブルが削除された後に新しく開発メンバーが加わり、そのメンバーが何らかの事情でこのマイグレーションファイルを走らせるとどうなるでしょう？  
その時点のコードベースには`Preference`モデルは存在しないはずですから、このマイグレーションはエラーになってしまいます。
するとその原因調査や修正に余計な手間が発生する事になります。

まあ実際には新たに DB 環境を作る場合は`db:schema:load`でスキーマファイルを読み込むでしょうから、実は過去のマイグレーションを走らせるタイミングってそれ程無いとは思います。
しかしそれでも、マイグレーションファイルが仕組み的に将来のどこでも実行される可能性を持っている以上は、それを配慮した作り方にせざるを得ないと思います。

というわけで、自分がこの例のようなマイグレーションを書くなら、デフォルト値には素直に対応する数値を書きます。

```ruby
t.integer :theme, null: false, default: 0
```

マジックナンバー感もあって気持ち悪い気はしますが、上述した考慮を踏まえるならこちらの方がマシだと思っています。
特に enum であれば、デフォルト値となる値を列挙の先頭に置くルールにしておけば、
どんな enum であっても`default: 0`という記述に統一できてよりマシかもしれません。

ただこういった配慮が必要になってしまう時点で、そもそもマイグレーションという履歴管理の仕方自体に問題があるとも考えられます。
実際、過去のマイグレーションがずっと残るのはコード管理の面でも不便な事があります。
例えばプロジェクトのコード規約が変わった時、過去のマイグレーションファイルにも適用すべきか、しないならリンタやフォーマッタの挙動をどうするか、ある時期より前のマイグレーションファイルだけ無視するような設定を入れるか、あるいはマイグレーションファイル全体を対象外としてしまうか...などと考える事が増えます。
そうなるくらいならマイグレーションという考え方自体を見直し、[Ridgepole][ridgepole] のように過去のマイグレーションファイルを必要としないやり方の方が良いのかもしれません。
まだ試してみた事はないのですが。

[ridgepole]: https://github.com/winebarrel/ridgepole

### データの変更を含める時は慎重に

これも前節の話に似ていますが、安易にデータの追加・更新・削除をマイグレーションに含めてしまうと、実行する環境やタイミングによって結果が変わってしまうケースがあります。
他にも下記のような懸念点があるので、やるならそれらを加味した上で問題ないかを判断するのが良さそうです:

- 決まった値のレコードを追加するようなケースだと、既存のデータ次第でユニーク成約や外部キー制約への違反によりマイグレーションが失敗する可能性がある。
- サーバへのデプロイ時に自動でマイグレーションを実行している場合は、データ更新に時間がかかるとデプロイ時間がのびてしまう。
- `db:schema:load`で DB を作る場合はデータ構造の定義のみが反映されるので、`db:migrate`がデータ操作まで含んでいると両者の実行結果にずれが出る。

### 互換性を保つマイグレーションを行う

これはマイグレーション単体ではなくコードベース全体の問題ですが、ロードバランシングを行っている本番環境などで複数のサーバ (正確には Rails アプリ) が同一の DB を参照している場合は注意が必要です。
マイグレーションによる DB の更新は一度だけ走るのに対し、サーバ上のソースコードの更新はサーバごとに行われる事になります。
するとサーバによっては「DB はマイグレーション実行後の状態だけどサーバ上のソースコードはマイグレーション実行前の状態」になる時間が生じうる事になるので、その間も問題なく動作するようなマイグレーションの仕方をする必要があります。

詳細はこちら: https://github.com/elafarge/blog-articles/blob/master/01-no-downtime-migrations/zero-downtime-database-migrations.md

とはいえ特に小・中規模のアプリだと、常にユーザがアクセスしているわけでもない機能の修正であれば、ほんの数分くらい互換性のない状態になっても問題ないケースは全然ありえます。
なのでこれも必要に応じて意識するという感じでしょうか。

## その他の Tips

以上で大体は書けたので、後は細かな考慮事項をメモしておきます。

## RuboCop は大いに活用する

インデントなどのフォーマットが意味もなくバラバラなコードは読みづらいと思うので、自分はだいたい [RuboCop][rubocop] を導入します。
ただ RuboCop のデフォルトルールには割とアグレッシブなものも多いので、あまり RuboCop を使いたくないという声もちらほら聞きます。
しかし設定は好きなようにカスタマイズ出来るし、ある種のフォーマットを自動で統一できる環境はとても便利だと思うので、自分は不要だと思うルールは積極的に無効にしつつ使っています。  
代表的なルールをいくつか挙げると:

- インデントやスペーシングの統一
- クォートの統一
- 末尾カンマの強制適用 or 排除
- 未使用変数の発見

などがあります。
ただ「どこまで統一したいと思うか」は確かに人によりそうで、例えば`n > 0`と`n.positive?`はどちらかに統一しようという[`Style/NumericPredicate`][rubocop-style-numeric-predicate]のようなルールもあるのですが、個人的にはそのくらいなら状況に応じてより読みやすそうな方を使えば良いように感じます。
しかしインデントの統一にはこだわるのになぜこちらにはこだわらないのかと言われるとあまりハッキリした答えはなく、ルールの数だけ bikeshed を引き起こしそうな面倒さはどうしてもあります。

[rubocop]: https://github.com/rubocop-hq/rubocop

[rubocop-style-numeric-predicate]: https://github.com/rubocop-hq/rubocop/blob/master/manual/cops_style.md#stylenumericpredicate

というわけで逆に普段使わないのは、

- 個人的に統一の必要性を感じないもの (主観性強い)
- メソッドの最大行数など各種メトリクス系

あたりです。
チーム開発の場合は種類が違うこだわりを持つ人がいると衝突するかもしれませんが、自分はとにかく統一されてる事重視なので、強い希望を持つ人がいるならその人の好みに合わせます。
逆に折り合いがつかなかったり、ルールの多さにストレスを感じる人もいるなら、全員が納得できるルールだけ使うのが良いでしょう。

メトリクスは1行の最大文字数だけ使いますが、クラスやメソッドの行数や複雑度 (ABCサイズなど) は使わないか、閾値をかなり高めに設定します。
デフォルトの閾値を超えるかどうかとコードの読みやすさは必ずしも相関しないと感じる事が割とあったので、
固定の閾値を設ける意義はあまり無いかなと思っています。

## テーブル定義の`timestamp`は前の方がいい？

ActiveRecord が自動でセットしてくれる`created_at`, `updated_at`というタイムスタンプカラムは、大体一番後ろのカラムとして定義されると思います。

```ruby
create_table :users do |t|
  t.string :name, null: false
  t.integer :age, null: false

  t.timestamps
end
```

ただ、最近これらのカラムは先頭に置いとく方が便利な気がしています。
その方が将来カラムを追加したくなった時に、カラムの追加位置を気にせずに済むからです。
例えば GUI クライアントなどで DB に直接アクセスして中身を確認する時、大抵はタイムスタンプも合わせて見たいし、後からカラムがタイムスタンプの後ろに追加されていると、パット見でタイムスタンプを見つけにくいです。
必要なカラムだけ明示的に SELECT する場合は困りませんが、`SELECT *`で済むならその方が楽です。
また MySQL なら`after`でカラムの追加位置を指定できますが、指定せずに済むならやはりその方が楽です。  
この規約を設けるとどのテーブルも共通して`id`, `created_at`, `updated_at`の3つからカラム定義が始まる形になり、何となくきれいではと思います。
が、実際に業務で試した事はまだありません。

## メソッド修飾子をステートレスにする？

Ruby には`private`や`protected`といったメソッド修飾子の書き方がいくつかありますが、メジャーなのは以下のように複数のメソッドにまとめて適用する方法だと思います:

```ruby
def SomeController
  # public methods
  def index
    some_index_logic
  end

  def show
    some_show_logic
  end

  private

  # private methods
  def some_index_logic
    # ...
  end

  def some_show_logic
    # ...
  end
end
```

自分も普段はこの書き方ですが、実は個々のメソッドにインラインで記述するスタイルで統一しておく方がメリットは大きいような気がしています。

```ruby
def SomeController
  def index
    some_index_logic
  end

  private def some_index_logic
    # ...
  end

  def show
    some_show_logic
  end

  private def some_show_logic
    # ...
  end
end
```

これなら「公開されているか」に関係なく関連するメソッド同士を近くにおけるし、たとえ将来巨大なクラスに成り果ててしまってもスクロール中「どこからが private だっけ？」とならずに済むからです。
とはいえ、こちらも実際に業務で試した事はありません。

## まとめ

まだ書き忘れてる事もありそうですが、とりあえずこの辺にしておきます。
主にコードのメンテナビリティについて意識する事を色々書きましたが、そもそもコードはまず正しく動く事が大前提というのも忘れてはいけないなと思います。
どんなに汚くて手をつけにくいコードでも正しく動いてるなら偉いし、逆にそれをないがしろにしたままコードや設計の良し悪しを議論するのは滑稽です。
ただこれらは別に相反するものではなく、むしろ複雑なユースケースであるほど、真っ当に設計する事が正しく動かすためには有効であるはずだとも思います。
コードは書かれた瞬間から絶えず読まれ修正されていくわけで、それがしやすいほど「正しく動く」の定義の変化に柔軟に対応していけるはずだからです。

参考: [Is High Quality Software Worth the Cost?](https://martinfowler.com/articles/is-quality-worth-cost.html)

あとは書いていて、 Rails のレールに収まらない諸々のワークアラウンドをフレームワーク化すると [Hanami][hanami] に行き着く気がしました。
まだ触ったことはないのですが、機会があれば試してみたいです。
どうせ自由に選べるならそもそも静的型付け言語を選びたい気もしますが。

[hanami]: https://hanamirb.org/

