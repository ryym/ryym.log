+++
draft = true
date = "2025-11-30T08:57:00+09:00"
tags = []
title = "Test-aware Design"
updated = "2025-11-30T08:57:00+09:00"
+++

## 概要

ソフトウェアのテストコードにおいて、スタブやモックといったテストダブルの使用を完全に避けることは難しい。
またテストダブルによるテストは、しばしばテスト対象のコンポーネントやその依存関係の内部実装詳細への密結合を引き起こす。
ここではテストダブルの使用を最小限にしつつ、内部実装に依存しないテストの方策として、アプリケーション自身にテストのための機能を持たせる案を検討してみる。

## 免責事項

- これはアイディアのメモであり、実用性を試してはいない。
- サンプルコードは Ruby だが、特に Ruby に閉じた話ではない。
  - よって以降では何らかの処理のまとまりを雑に「コンポーネント」と呼ぶが、大抵の言語ではクラスに相当する想定。

## 課題: 間接的な依存関係に対するテストダブル

テストダブルは主に以下のような理由で使われる。

- **外部環境からの隔離:** 外部サービスのAPIコールやメール送信など、テスト実行のたびに走らせたくない処理を置き換える。
- テスト対象のコンポーネントが依存する他のコンポーネントを、以下の目的で置き換える。
  - **依存関係からの隔離:** テストが依存コンポーネント側の実装ミスやパフォーマンス等に左右されるのを防ぐ。
  - **依存関係のコントロール:** 依存コンポーネントの振る舞いを変え、エッジケースなどの各種パターンを再現する。
  - **省力化:** 依存コンポーネントを正しくセットアップする手間やコストを省く。
- **過程の検証:** テスト対象の振る舞いをその結果から検証することが難しい場合に、結果ではなく過程の検証で代替する。
  - 例えば期待通りにキャッシュを使えているかの検証として、
    テスト対象コンポーネントがキャッシュにのみアクセスし、値の計算処理を呼び出していないことを確認するなど [^1]。

[^1]: <https://martinfowler.com/articles/mocksArentStubs.html> に出ていた例。

工夫次第でテストダブルの使用を減らすことはできるが、このうち特に「外部環境からの隔離」や「依存関係のコントロール」あたりでは、テストダブルを使う以上に現実的な手段がないことも少なくない。

とはいえどのような目的であれ、直接的な依存関係をテストダブルに置き換えるだけなら、あまり課題はない。
適宜テストダブルを用意し、それらを使ってテスト対象のコンポーネントを動かせばいい。

```ruby
# TODO
```

面倒なのは、テスト対象コンポーネントの依存関係の依存関係のような、間接的な依存先が持つ処理をテストダブルに置き換えたいケースだ。
それを行うには内部実装の詳細に踏み込み、どのコンポーネントが何に依存してどんな処理をするのかを把握して、テストダブルを設定せねばならない。

例: todo

```ruby
# TODO
```

しかしこれでは正しくテストダブルをセットアップするのが手間だし、テストコードが内部実装に強く依存して壊れやすくなる。

もし開発チームが「常に直接の依存関係のみをテストダブルに差し替えてテストする」方針で合意するなら、この問題は発生しない。
直接の依存関係が全てテストダブルになるなら、その更に先の依存関係については気にしなくて済む。
この方針は十分有用だと思うが、各コンポーネントを完全に隔離して行うテストが大半になると、コンポーネント間の結合において生じる問題を見逃しやすくなったり、テストの冗長性が減じたりといったデメリットはある。
テストダブルの使用を本当に必要なケースに絞れるなら、テストとしてはその方がより堅牢になると自分は思う。

必要な時だけ局所的にテストダブルを使う方針の場合、間接的な依存関係の置き換えにはどんな方法があるだろうか？  
例えばテストダブルに置き換えたい処理が何らかのAPIコールだとしたら、以下の方法が考えられる。

- APIクライアントのテストダブルを外から渡し、それを使うコンポーネントまでひたすらリレーしていく。
  - クラスのコンストラクターで依存関係を受け取るとか。
- テスト実行前に、APIクライアントのインスタンスがテストダブルとなるよう設定する。
  - [RSpec] の `allow(SomeApi).to receive(:new).and_return(stub)` とか。
  - DIコンテナーにテストダブルを登録するとか。
- APIコールを自動的に代替物に置き換える。
  - APIリクエストをキャッチし、実際のリクエストを投げずフェイクのレスポンスを返す仕組みとか。
  - 実際にAPI通信ができるデモサービスを動かしておくとか。

[RSpec]: https://rspec.info/

TODO: 型安全な Effect System があったら、この記事で考える課題はもしかして発生しない？

どの方法にせよ、テストダブルを正しく使うには以下の内部実装の知識が必要になってしまう。

- 依存関係のどこかにあるコンポーネントが、特定のAPI (クライアント) に依存していること。
- そのAPI (クライアント) の使われ方。

あるいは、テスト時にはそのAPIコールがデフォルトでテストダブルに置き換わるようにしておく手もある。
これなら各テストが個別にテストダブルを設定する必要はなく、内部実装の知識もいらない。
確かにこれで十分なケースは多いが、中にはAPIコールの結果 (成否やレスポンス内容) が、依存関係を通じてテスト対象コンポーネントの振る舞いに影響を与えるケースもある。
このようなケースでAPIの結果パターンごとのテストを書きたい場合には、何らかの方法で間接的な依存関係の中にあるAPIコールの結果をコントロールしなければならない。
それにはAPIクライアントの使われ方やリクエスト・レスポンスの構造といった、内部実装の知識がやはり必要となる。

テスト対象コンポーネントの振る舞いがそのAPIの結果に依存するなら、
テストコードが「処理内のどこかでそのAPIが呼ばれる」程度の知識を持つことは自然かもしれないが、
詳細な内部実装知識の漏れは、テストコードの話とはいえコード間の結合度を必要以上に上げてしまう。
実際API (クライアント) の使われ方に変更があるたびに、それに依存するテストコードにも変更が必要になるだろう。

ここまでをまとめると、以下の状況でテストダブルを使う場合に、どうしても関連する内部実装の知識が露出するのでは、それって辛くないか、というのが今の懸念といえる。

- テストダブルの使用は最小限とし、外部APIコールなど置き換えざるを得ない処理に対してのみ使う方針である。
- テスト対象コンポーネントの間接的な依存関係の中にテストダブルを必要とする処理があり、かつその処理の複数のパターンをテストしたい。

このような状況が恐らく多くはなく、かつテストダブルのためにコンポーネントの内部詳細が多少露出するのは現実的には許容すべきかもしれないが、
それを踏まえた上でこの課題を解消する案を次に考えてみたい。

## 案: テストのユースケースを組み込んだアプリ

今自分が考えている案は、テストのために各種振る舞いを再現する責務を各コンポーネント自体に組み込んでしまうことだ。
例えばAPIクライアントを内部で使う場合、一般的にはそれを引数等で外から注入可能にしておき、テスト時にはテストダブルに置き換える。
これをもう一歩踏み込んで、テストで検証したい各種振る舞い自体を引数で指定可能にし、必要な振る舞いをアプリケーションコード側で提供するのはどうだろう？

```ruby
# TODO
```

内部的には引き続きテストダブル相当の仕組みを使うことになるだろうが、
各種振る舞いの具体的な再現方法を用意・管理する責務はテストコードからアプリケーションコードに移り、かつコンポーネント内に閉じる。
各コンポーネントは再現したい振る舞いを指定されたら、その振る舞いを実現するために必要な内部の振る舞いを、自身が依存するコンポーネントに対して指定する。これを末端のコンポーネントまで繰り返す。
多くのコンポーネントは単に指定内容を変換・リレーするだけでよいはずで、APIコールなど置き換えるべき処理を含むコンポーネントのみが、指定内容に応じて振る舞いを変える形になる。

もちろんテストのようにアプリケーションの用途とは無関係なものをコード内に混ぜ込むのは、本来なら避けるべきだ。
しかし自動テストによる継続的・網羅的な検証はアプリケーションの品質維持・向上に欠かせないし、
今でもすでにテストのためだけにあえてインターフェイスを定義して実装を差し替え可能にする、程度のことは普通に行われる。
ならばいっそアプリケーション自体にテストのためのユースケースを組み込むのは、それでテストの実施しやすさや保守性が向上するなら、取りうる選択肢に思える。
その場合でもテスト用の処理とアプリケーション本来の処理は可能な限り分離し、予期せぬ影響を与えないようには注意が必要だろう。

この方針であれば前述の課題は解消する。
テスト時には対象のコンポーネントに対して期待する振る舞いを指定するだけでよく、テストコード側が対象コンポーネントの内部を管理する必要はなくなる。

ざっと挙げられるメリットは以下だ。

- テストコードが対象コンポーネントや依存関係の内部実装を詳しく知らずに済む。
- 再現すべき振る舞いがコンポーネントのインターフェイス (引数) として可視化され、どのようなパターンがありどんなパラメーターに左右されるのかが明確になる。
- リッチなモックライブラリや依存性注入などの必要性が大きく減る。

コンポーネントに再現したい振る舞いを指定してテストするのは、一見テストダブルに対してテストを書いてるみたいな不毛なコードにも見えるが、
実際にやっていることはテストコード内でテストダブルを設定して行うテストと変わらない。ただテストダブルの設定責務がアプリケーションコード側に移っただけだ。

そしてこの方針にはメリットがもう1つある。それは単体テストにとどまらず、同じ仕組みをより上位の統合テストでも利用できることだ。
テストダブルを必要とするコンポーネントがあると、それを使うAPIのテスト、またそのAPIを使うWebページのテスト、といった上位レイヤーでも都度テストダブルの考慮が必要になる。
しかしこれも「引数により再現したい振る舞いを指定する」という案を拡張すれば、同様に解決できる。
例えばWebサービスであれば、HTTPリクエストヘッダーやURLのクエリパラメーターを通じて、再現したい振る舞いを外から指定可能にするのはどうだろう。
エンドポイントのハンドラー (コントローラー) はその引数を解釈し、それを依存コンポーネントにリレーしていくことで、理想的にはあらゆる振る舞いを再現できる。
これなら上位レイヤーの統合テストでも必要に応じてテストダブルが使えるし、エラーやエッジケースのテストも実施しやすい。

もし同じ仕組みを他の依存サービスにも適用できれば、更にできることは広がる。例えばAPIコール時に振る舞い再現用のパラメーターを呼び出し先にも渡す。
すると実際にサービス間通信まで行いつつ、厄介な処理だけを局所的にスキップしたり、エッジケースを再現したりしながら統合テストを実施できる。

加えてテスト以外の用途も考えられる。やはり通常の状況では発生しづらいエッジケースやエラーを開発環境で再現してデバッグしたり、ステージング環境で実際に動くデモをチームメンバーやユーザーに見せれたりしたら、結構便利ではなかろうか。

ただテスト環境以外で使う場合には以下の注意が必要だろう。

- 本番環境では当然、どんな振る舞いの再現を指定されても無視する必要がある。
- 開発環境であっても、テスト環境とは異なり実際のDBをリセット等せず使うなら、データ不整合につながりうる。

ただこの案がどの程度現実的なのかはわからない。少なくとも以下のようなデメリットがあることは明らかだ。

- アプリケーション内にテスト用のコードが混ざることで、意図せぬ事故につながるリスクが生まれる。
- 引数による振る舞い再現のために、インターフェイスや内部実装が複雑化する。
  - この複雑さは従来テストコードが受け持っていたと考えれば、それを各コンポーネントごとに内部管理できるのは凝集性の観点ではよいことかもしれない。
    けどテスト環境以外でも走りうる点の考慮など、これまでにはなかった類の複雑さまで持ち込んでしまう。

## 過程の検証は結果の検証に置き換える

ここまでは単なる処理の置き換え、いわゆるスタブ目的のテストダブルを念頭に置いた話だった。
しかしいわゆるモックやスパイによる過程の検証を行いたいケースでは、単に実処理がテストダブルに置き換わるだけでは駄目で、処理の過程を検証できることが求められる。
例えばAPIで外部サービスに何らかのデータを登録することがゴールの処理なら、APIクライアントをモックに置き換えた上で、コンポーネントが想定通りのパラメータでAPIクライアントの特定のメソッドを呼んでいるかを検証せねばならない。
そのようなケースではどうするか。

一番いいのは、可能な限り過程ではなく結果による検証にすり替えることだろう。
先程の例でいえば、もしAPIのレスポンスに登録データのIDなど何かしら処理の成功を示す値が含まれるなら、それをコンポーネントの戻り値に含めればいい。
戻り値を検証してテストダブルが返したIDを持っていれば、かつテストダブルが正しいパラメータで呼ばれた時のみ成功レスポンスを返すのならば、
コンポーネントは想定通りにAPIを呼んだとわかる。

結果による検証が難しい場合には、簡易的なイベントシステムを使う方法もある。
DBのテーブルなりグローバル変数なりイベントを格納する場所を用意して、テストダブルは処理の結果をそこにイベントとして書き込む。
テストでは処理完了後に書き込まれたイベントの内容を確認することで、想定通りにテストダブルが使われたかを検証する。  
こうすればテストダブルは本来の処理を置き換えるだけで済むから、アプリケーションコード側で振る舞いの再現を管理する前述の案が適用可能になる。
「特定のメソッドが特定の引数で呼ばれたか」のような、内部実装に強く紐づく形での検証は不要となる。

## 終わりに

この記事で述べたようなテストダブル使用の課題は、現実的にはテストダブルの管理を集約したり置き換えを自動化したりすれば、それほど大きな課題にはならないと思う。
一方でアプリケーション自体がエラーやエッジケースを含む各種振る舞いの再現方法を提供できるなら、それはテストを始め開発全体で役に立ちそうだ。
しかしそのメリットがこの仕組みを実装・維持するコストを上回るかどうかは、実際に試してみないとわからない。

---

<!-- - サービスの責務が入れ子になる例、 Apple の購読管理とかいいかも？　本来なら webhook 使うからそれはあれだけど。 -->
