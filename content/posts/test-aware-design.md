+++
draft = true
date = "2025-11-30T08:57:00+09:00"
tags = []
title = "Test-aware Design"
updated = "2025-11-30T08:57:00+09:00"
+++

## 概要

ソフトウェアのテストコードにおいて、スタブやモックといったテストダブルの使用を完全に避けることは難しい。
またテストダブルによるテストは、しばしばテスト対象のコンポーネントやその依存関係の内部実装詳細への密結合を引き起こす。
ここではテストダブルの使用を最小限にしつつ、内部実装に依存しないテストの方策として、アプリケーション自身にテストのための機能を持たせる案を検討してみる。

## 免責事項

- これはアイディアのメモであり、実用性を試してはいない。
- サンプルコードは Ruby だが、特に Ruby に閉じた話ではない。
  - よって以降では何らかの処理のまとまりを雑に「コンポーネント」と呼ぶが、大抵の言語ではクラスに相当する想定。

## 課題: 間接的な依存関係に対するテストダブル

テストダブルは主に以下のような理由で使われる。

- **外部環境からの隔離:** 外部サービスのAPIコールやメール送信など、テスト実行のたびに走らせたくない処理を置き換える。
- テスト対象のコンポーネントが依存する他のコンポーネントを、以下の目的で置き換える。
  - **依存関係からの隔離:** テストが依存コンポーネント側の実装ミスやパフォーマンス等に左右されるのを防ぐ。
  - **依存関係のコントロール:** 依存コンポーネントの振る舞いを変え、エッジケースなどの各種パターンを再現する。
  - **省力化:** 依存コンポーネントを正しくセットアップする手間やコストを省く。
- **過程の検証:** テスト対象の振る舞いをその結果から検証することが難しい場合に、結果ではなく過程の検証で代替する。
  - 例えば期待通りにキャッシュを使えているかの検証として、
    テスト対象コンポーネントがキャッシュにのみアクセスし、値の計算処理を呼び出していないことを確認するなど [^1]。

[^1]: <https://martinfowler.com/articles/mocksArentStubs.html> に出ていた例。

工夫次第でテストダブルの使用を減らすことはできるが、このうち特に「外部環境からの隔離」や「依存関係のコントロール」あたりでは、テストダブルを使う以上に現実的な手段がないことも少なくない。

とはいえどのような目的であれ、直接的な依存関係をテストダブルに置き換えるだけなら、あまり課題はない。
適宜テストダブルを用意し、それらを使ってテスト対象のコンポーネントを動かせばいい。

```ruby
# TODO
```

面倒なのは、テスト対象コンポーネントの依存関係の依存関係のような、間接的な依存先が持つ処理をテストダブルに置き換えたいケースだ。
それを行うには内部実装の詳細に踏み込み、どのコンポーネントが何に依存してどんな処理をするのかを把握して、テストダブルを設定せねばならない。

例: todo

```ruby
# TODO
```

しかしこれでは正しくテストダブルをセットアップするのが手間だし、テストコードが内部実装に強く依存して壊れやすくなる。

もし開発チームが「常に直接の依存関係のみをテストダブルに差し替えてテストする」方針で合意するなら、この問題は発生しない。
直接の依存関係が全てテストダブルになるなら、その更に先の依存関係については気にしなくて済む。
この方針は十分有用だと思うが、各コンポーネントを完全に隔離して行うテストが大半になると、コンポーネント間の結合において生じる問題を見逃しやすくなったり、テストの冗長性が減じたりといったデメリットはある。
テストダブルの使用を本当に必要なケースに絞れるなら、テストとしてはその方がより堅牢になると自分は思う。

必要な時だけ局所的にテストダブルを使う方針の場合、間接的な依存関係の置き換えにはどんな方法があるだろうか？  
例えばテストダブルに置き換えたい処理が何らかのAPIコールだとしたら、以下の方法が考えられる。

- APIクライアントのテストダブルを外から渡し、それを使うコンポーネントまでひたすらリレーしていく。
  - クラスのコンストラクターで依存関係を受け取るとか。
- テスト実行前に、APIクライアントのインスタンスがテストダブルとなるよう設定する。
  - [RSpec] の `allow(SomeApi).to receive(:new).and_return(stub)` とか。
  - DIコンテナーにテストダブルを登録するとか。
- APIコールを自動的に代替物に置き換える。
  - APIリクエストをキャッチし、実際のリクエストを投げずフェイクのレスポンスを返す仕組みとか。
  - 実際にAPI通信ができるデモサービスを動かしておくとか。

[RSpec]: https://rspec.info/

TODO: 型安全な Effect System があったら、この記事で考える課題はもしかして発生しない？

どの方法にせよ、テストダブルを正しく使うには以下の内部実装の知識が必要になってしまう。

- 依存関係のどこかにあるコンポーネントが、特定のAPI (クライアント) に依存していること。
- そのAPI (クライアント) の使われ方。

あるいは、テスト時にはそのAPIコールがデフォルトでテストダブルに置き換わるようにしておく手もある。
これなら各テストが個別にテストダブルを設定する必要はなく、内部実装の知識もいらない。
確かにこれで十分なケースは多いが、中にはAPIコールの結果 (成否やレスポンス内容) が、依存関係を通じてテスト対象コンポーネントの振る舞いに影響を与えるケースもある。
このようなケースでAPIの結果パターンごとのテストを書きたい場合には、何らかの方法で間接的な依存関係の中にあるAPIコールの結果をコントロールしなければならない。
それにはAPIクライアントの使われ方やリクエスト・レスポンスの構造といった、内部実装の知識がやはり必要となる。

テスト対象コンポーネントの振る舞いがそのAPIの結果に依存するなら、
テストコードが「処理内のどこかでそのAPIが呼ばれる」程度の知識を持つことは自然かもしれないが、
詳細な内部実装知識の漏れは、テストコードの話とはいえコード間の結合度を必要以上に上げてしまう。
実際API (クライアント) の使われ方に変更があるたびに、それに依存するテストコードにも変更が必要になるだろう。

ここまでをまとめると、以下の状況でテストダブルを使う場合に、どうしても関連する内部実装の知識が露出するのでは、それって辛くないか、というのが今の懸念といえる。

- テストダブルの使用は最小限とし、外部APIコールなど置き換えざるを得ない処理に対してのみ使う方針である。
- テスト対象コンポーネントの間接的な依存関係の中にテストダブルを必要とする処理があり、かつその処理の複数のパターンをテストしたい。

このような状況が恐らく多くはなく、かつテストダブルのためにコンポーネントの内部詳細が多少露出するのは現実的には許容すべきかもしれないが、
それを踏まえた上でこの課題を解消する案を次に考えてみたい。

## 案: テストのユースケースを組み込んだアプリ

今自分が考えている案は、テストのために各種振る舞いを再現する責務を各コンポーネント自体に組み込んでしまうことだ。
例えばAPIクライアントを内部で使う場合、一般的にはそれを引数等で外から注入可能にしておき、テスト時にはテストダブルに置き換える。
これをもう一歩踏み込んで、テストで検証したい各種振る舞い自体を引数で指定可能にし、必要な振る舞いをアプリケーションコード側で提供するのはどうだろう？

```ruby
# TODO
```

内部的には引き続きテストダブル相当の仕組みを使うことになるだろうが、
各種振る舞いの具体的な再現方法を用意・管理する責務はテストコードからアプリケーションコードに移り、かつコンポーネント内に閉じる。
各コンポーネントは再現したい振る舞いを指定されたら、その振る舞いを実現するために必要な内部の振る舞いを、自身が依存するコンポーネントに対して指定する。これを末端のコンポーネントまで繰り返す。
多くのコンポーネントは単に指定内容を変換・リレーするだけでよいはずで、APIコールなど置き換えるべき処理を含むコンポーネントのみが、指定内容に応じて振る舞いを変える形になる。

もちろんテストのようにアプリケーションの用途とは無関係なものをコード内に混ぜ込むのは、本来なら避けるべきだ。
しかし自動テストによる継続的・網羅的な検証はアプリケーションの品質維持・向上に欠かせないし、
今でもすでにテストのためだけにあえてインターフェイスを定義して実装を差し替え可能にする、程度のことは普通に行われる。
ならばいっそアプリケーション自体にテストのためのユースケースを組み込むのは、それでテストの実施しやすさや保守性が向上するなら、取りうる選択肢に思える。
その場合でもテスト用の処理とアプリケーション本来の処理は可能な限り分離し、予期せぬ影響を与えないようには注意が必要だろう。

この方針であれば前述の課題は解消する。
テスト時には対象のコンポーネントに対して期待する振る舞いを指定するだけでよく、テストコード側が対象コンポーネントの内部を管理する必要はなくなる。

ざっと挙げられるメリットは以下だ。

- テストコードが対象コンポーネントや依存関係の内部実装を詳しく知らずに済む。
- 再現すべき振る舞いがコンポーネントのインターフェイス (引数) として可視化され、どのようなパターンがありどんなパラメーターに左右されるのかが明確になる。
- リッチなモックライブラリや依存性注入などの必要性が大きく減る。

コンポーネントに再現したい振る舞いを指定してテストするのは、一見テストダブルに対してテストを書いてるみたいな不毛なコードにも見えるが、
実際にやっていることはテストコード内でテストダブルを設定して行うテストと変わらない。ただテストダブルの設定責務がアプリケーションコード側に移っただけだ。

そしてこの方針にはメリットがもう1つある。それは単体テストにとどまらず、同じ仕組みをより上位の統合テストでも利用できることだ。
テストダブルを必要とするコンポーネントがあると、それを使うAPIのテスト、またそのAPIを使うWebページのテスト、といった上位レイヤーでも都度テストダブルの考慮が必要になる。
しかしこれも「引数により再現したい振る舞いを指定する」という案を拡張すれば、同様に解決できる。
例えばWebサービスであれば、HTTPリクエストヘッダーやURLのクエリパラメーターを通じて、再現したい振る舞いを外から指定可能にするのはどうだろう。
エンドポイントのハンドラー (コントローラー) はその引数を解釈し、それを依存コンポーネントにリレーしていくことで、理想的にはあらゆる振る舞いを再現できる。
これなら上位レイヤーの統合テストでも必要に応じてテストダブルが使えるし、エラーやエッジケースのテストも実施しやすい。

もし同じ仕組みを他の依存サービスにも適用できれば、更にできることは広がる。例えばAPIコール時に振る舞い再現用のパラメーターを呼び出し先にも渡す。
すると実際にサービス間通信まで行いつつ、厄介な処理だけを局所的にスキップしたり、エッジケースを再現したりしながら統合テストを実施できる。

加えてテスト以外の用途も考えられる。やはり通常の状況では発生しづらいエッジケースやエラーを開発環境で再現してデバッグしたり、ステージング環境で実際に動くデモをチームメンバーやユーザーに見せれたりしたら、結構便利ではなかろうか。

ただテスト環境以外で使う場合には以下の注意が必要だろう。

- 本番環境では当然、どんな振る舞いの再現を指定されても無視する必要がある。
- 開発環境であっても、テスト環境とは異なり実際のDBをリセット等せず使うなら、データ不整合につながりうる。

ただこの案がどの程度現実的なのかはわからない。少なくとも以下のようなデメリットがあることは明らかだ。

- アプリケーション内にテスト用のコードが混ざることで、意図せぬ事故につながるリスクが生まれる。
- 引数による振る舞い再現のために、インターフェイスや内部実装が複雑化する。
  - この複雑さは従来テストコードが受け持っていたと考えれば、それを各コンポーネントごとに内部管理できるのは凝集性の観点ではよいことかもしれない。
    けどテスト環境以外でも走りうる点の考慮など、これまでにはなかった類の複雑さまで持ち込んでしまう。

## 過程の検証は結果の検証に置き換える

ここまでは単なる処理の置き換え、いわゆるスタブ目的のテストダブルを念頭に置いた話だった。
しかしいわゆるモックやスパイによる過程の検証を行いたいケースでは、単に実処理がテストダブルに置き換わるだけでは駄目で、処理の過程を検証できることが求められる。
例えばAPIで外部サービスに何らかのデータを登録することがゴールの処理なら、APIクライアントをモックに置き換えた上で、コンポーネントが想定通りのパラメータでAPIクライアントの特定のメソッドを呼んでいるかを検証せねばならない。
そのようなケースではどうするか。

一番いいのは、可能な限り過程ではなく結果による検証にすり替えることだろう。
先程の例でいえば、もしAPIのレスポンスに登録データのIDなど何かしら処理の成功を示す値が含まれるなら、それをコンポーネントの戻り値に含めればいい。
戻り値を検証してテストダブルが返したIDを持っていれば、かつテストダブルが正しいパラメータで呼ばれた時のみ成功レスポンスを返すのならば、
コンポーネントは想定通りにAPIを呼んだとわかる。

結果による検証が難しい場合には、簡易的なイベントシステムを使う方法もある。
DBのテーブルなりグローバル変数なりイベントを格納する場所を用意して、テストダブルは処理の結果をそこにイベントとして書き込む。
テストでは処理完了後に書き込まれたイベントの内容を確認することで、想定通りにテストダブルが使われたかを検証する。  
こうすればテストダブルは本来の処理を置き換えるだけで済むから、アプリケーションコード側で振る舞いの再現を管理する前述の案が適用可能になる。
「特定のメソッドが特定の引数で呼ばれたか」のような、内部実装に強く紐づく形での検証は不要となる。

## 終わりに

この記事で述べたようなテストダブル使用の課題は、現実的にはテストダブルの管理を集約したり置き換えを自動化したりすれば、それほど大きな課題にはならないと思う。
一方でアプリケーション自体がエラーやエッジケースを含む各種振る舞いの再現方法を提供できるなら、それはテストを始め開発全体で役に立ちそうだ。
しかしそのメリットがこの仕組みを実装・維持するコストを上回るかどうかは、実際に試してみないとわからない。

---

<!-- - サービスの責務が入れ子になる例、 Apple の購読管理とかいいかも？　本来なら webhook 使うからそれはあれだけど。 -->

```ruby
# 雑な例: 何らかの注文の支払いを実行するクラス
class OrderPaymentService
  def initialize(payment_api: PaymentApi.new, notification_service: NotificationService.new)
    # ...
  end

  # payment_api による支払いの実行、 notification_service による確認メールの送信を含む。
  def process_payment(order:)
    # ...
  end
end
```

```ruby
test "mark Order status declined if payment is declined" do
  service = OrderPaymentService.new(
    payment_api: PaymentApiMock.new(mode: :charge_declined),
    notification_service: NotificationServiceMock.new,
  )
  # ...
end
```

面倒なのは、そのような差し替えたい依存がテスト対象の奥深くに存在する場合だ。例:

- 内部的に `OrderPaymentService` を使う別のクラスのテスト
- 内部的に `OrderPaymentService` を使う Web API のテスト

外部サービスへの API コールやメール送信は `OrderPaymentService` に依存するあらゆる処理で発生することになる。
そのため `OrderPaymentService` に直接的・間接的に依存するあらゆる処理のテストには、以下が求められる。

- `OrderPaymentService` が外部に依存する処理を行うと、まず知っていること。
- 外部に依存する処理を、必要に応じて適切にモックに差し替えられること。

特に2点目は `OrderPaymentService` の内部実装に関する知識を暗に要求し、コンポーネント間の依存関係を必要以上に強めてしまう。
自分が知っている範囲では、以下のような対処法がある。

1. どんなクラスのテストであれ、直接の依存関係を常にモックに差し替えてテストする。
2. 何らかの方法で、差し替えたい依存を外から指定する。
3. 外部依存へのクライアントをモックにするのではなく、外部サービス自体のモックを使う。

方法1はいわゆるロンドン学派に相当する考え方で、上記例でいえば `OrderPaymentService` 自体をモックに差し替えてテストする形になる。これなら、実際の処理では内部的に API コールやメール送信が走ることを気にせずに済む。

この方針でテストコードを書く方針に開発チームが合意するなら、それでこの課題は解消する。
一方でなんでもかんでもモックにすると、コンポーネント間の結合時に発生する問題を見落としやすくなったり、各テストが対象の内部実装の詳細に依存しやすくなったり、デメリットもある。もしモックにせざるを得ない部分以外は実際の処理を使ってテストできるなら、その方がテストの信頼性は高いと言える。

方法2は言語やフレームワークによって色々やり方があるだろうが、一番単純なのは差し替えが必要な依存を引数でリレーしていくことだろう。

```ruby
# OrderPaymentService に依存する別のクラス
class SubscriptionBillingService
  def initialize(payment_api: PaymentApi.new, notification_service: NotificationService.new)
    @order_payment_service = OrderPaymentService.new(payment_api:, notification_service:)
  end
end

test "process monthly recurring billing" do
  service = SubscriptionBillingService.new(
    payment_api: PaymentApiMock.new(mode: :success),
    notification_service: NotificationServiceMock.new,
  )
  # ...
end
```

強力なテストライブラリや DI コンテナなど、直接引数を渡さずに差し替えを実現する手もありえる。

```ruby
# RSpec
allow(PaymentApi).to receive(:new).and_return(payment_api_mock)

# Dependency injection (imaginary)
DI.register(PaymentApi, payment_api_mock)
```

しかしどんな方法であれ、 `OrderPaymentService` が他のどんなクラスに依存しているかは知らないといけない。
特に各種失敗やエラーケースをテストしたい場合、 `PaymentApi` のどのメソッドをどのように失敗させる必要があるか、といった知識も必要になる。

方法3は実際の外部サービスと同等に振る舞うダミーのサービスを起動し、 `PaymentApi` 等のクライアントをダミーのサービスにアクセスさせてテストする方法だ。これならアプリケーション内のテストではモックを一切使う必要がなく便利だが、やはりエラーやエッジケースといったバリエーションをテストしたい場合、何らかの方法でダミーのサービスがそういうレスポンスを返すよう設定しなければならない。
つまり `OrderPaymentService` と外部サービスがどのように通信するかの知識は漏れることになる。
また特定の条件でのみ API コールを失敗させる、といった柔軟な対応もしづらいことが多い。
方法3のバリエーションとして、ダミーのサービスを起動するのではなく API リクエストを何らかの方法でキャッチしてダミーのレスポンスを返す、といった仕組みを使う手もあるが、やはり API の詳細を知らなければならない。

sample code

- 常に直接の依存関係をモックする。
- 外からモックをリレーする。 (リレーじゃなくても、間接的な依存関係を指定する)
- 外部のダミーサービスを使う。

1の方針で統一するなら、話はそれで終わり。コンポーネント間の統合は別途テスト
1以外の方法では、どうしても内部の実装詳細に依存する。

---

アイディアのメモであり、実際に試してはいない。

- 多くのサービス開発では、テスト時にモックが必要。
- モックをどの程度使うべきかには流派があるが、使用を完全に0にすることは難しい。
- モックを使うテストはしばしば煩わしい。特に間接的な依存をモックしたい場合、テスト対象のコードの内部詳細に大きく依存する。
- 内部実装に強く依存せず、テスト時に実行できない副作用を迂回するには (例: 外部APIの使用)
  - 直接の依存関係を常にモックする (ロンドン学派)。
    - 確かにモックだらけにはなるが、実際どのくらいデメリットがあるんだろう。単体テストとその考え方に何かあったような。
  - クライアントをモックするのではなく、ダミーのサーバーを作ってそこにリクエストする。
    - 成功 (デフォルト) 以外のパターンを試したい場合、結局何らかの方法で結果を指示する方法が必要。
  - 差し替えが必要になりえるクラス (api client etc) は内部に隠さず、引数でリレーする。
    - 結局そのクライアントのどのメソッドがどういう風に失敗してほしいか、を外から指定しないといけないのは内部実装依存。

本来アプリケーションがテストを意識した作りになるのは避けるべきだが、いうて DI とかインターフェイスとかテストのために必要になることは多いし、実際有用。ならもう一歩踏み込んで、テストのシナリオまでここのサービスが管理できる方が、より凝集的でいいのでは。

内部実装に依存せずいい感じにやる第三の案: アプリケーションコード側が、テストのユースケースにも対応する。

簡潔にやりたければロンドン学派方式でいいと思うが、一応下記のメリットはある。

- モックを最小限にできる。
- 単体テスト以外でも、例えばリクエストヘッダー等で simulate を指定してモックを使える。
  - サービス間の統合テストにはならないが、アプリ内での統合はテストできるし、エッジケース等を自由に再現できたら便利では。
  - それに依存先のサービスもコントロール下にあるなら、そちらでも同様の test-aware な作りにして引数で挙動を変えられるようにすれば、サービス間の統合もテストしつつ各種パターンをシミュレートできる。

ただし実装は面倒になる。

---

- アイディアのメモのみで試してない
- 外部APIの呼び出し、滅多に起きない失敗のケースなど、モックが必要な場面は0にはならない
- テスト時のモックの流派はあるが、どちらもメリデメあり
  - 全部をモックするのはセットアップが面倒になりがちだし、結合時の問題を見落としやすくなる
  - なるべくモックしない方が信頼性も高まるが、間接的な依存をモックせざるを得ない時に不便
- いっそアプリケーション本体にテストのための機能を追加してしまうのはどうか
  - `simulate: <pattern( | patterns)?>`
  - 各サービス (?) は、本来の処理に加え、その中で置きうるパターンのシュミレーションを合わせて提供する責務を持つ
  - 外からはシュミレートしたいパターンを指定するだけ。内部の構造を知る必要がない
  - サービスは自身の依存関係に対して、指定されたシミュレーションを実行するために必要なパターンを再帰的に指定していく
  - ほとんどのサービスはただシミュレーションのパターンをリレー・変換するだけ
  - 末端の、実際にテストでは実行できない処理を行うクラスのみ、処理内容を simulate に応じて置き換える
- この方針のいいところ
  - テストフレームワーク非依存
  - 単体テスト以外でも使える。
    - Webアプリなら URL やリクエストヘッダーでパターンを指定可能にすれば、E2Eテスト等でもシミュレートできる
    - 依存するマイクロサービスがあれば、実際に通信はしつつパターン指定によりわざと失敗させる、とかもできそう
- この方針のしんどそうなところ
  - 試したいパターンが多い処理では、指定方法が複雑になりうる
  - そもそもテストのためのコードを混ぜ込むことをどの程度許容できるか
- 値の取得ではなく更新、すなわち実際の結果がアプリケーションの外部を確認しないとわからないような副作用は、
  別途それ用の仕組みを作れると良さそう。シミュレーション時には特定のテーブルに結果を書き込むとか。

---

主に Rails におけるテスタビリティの確保について、ふと思いついた案。試してない

テストにおいてモックをどの程度使うかには流派があると思う (積極的に使ってテストの責務を分離 or 最小限にして実動作で担保)

モックを最小限にして、必要な箇所以外では実際のコードを使う
(テストの重複を多少は許容する)
(でもこの辺の話なくても別に良いか)

モックの必要性が 0 になることはない
間接的な依存関係にあるやつをモックに差し替えるのがしんどい
単に常に特定のパターンになれば良いならデフォルトでモックすれば良いが、失敗ケースをテストしたいとか、別の挙動を指定したい時は特に
無理にアプリケーションコードをテストと分離せず、積極的にテストを意識してしまって良いかも

`A->B->C` という3段階の依存がある自然な例がほしい。 C が外部との通信 (とか面倒な副作用) を持つ。
でも全部サービスじゃなくても、 A はコントローラでも良いのか。

```ruby
# app/features/billing/build_summary.rb
class Billing::BuildSummary
  def initialize(payment_api: PaymentApi.new, collect_service_usage: Stat::CollectServiceUsage.new)
    @payment_api = payment_api
    @collect_service_usage = collect_service_usage
  end

  if Env.test?
    def self.new(mode: :default)
      case mode
      in :default
        super()
      in :payment_history_error
        super(
          payment_api: PaymentApi.new(failures: {
            get_payment_history: PaymentApi::NetworkError.new('fake error'),
          })
        )
      in :unexpected_error
        super(collect_service_usage: Mock::Feature.will_raise(NoMethodError))
      end
    end
  end

  def run(account:)
    payment_method = @payment_api.get_payment_method(account:)

    payment_history = begin
      if payment_method
        @payment_api.get_payment_history(account:, max: 5, order: :newest)
      else
        PaymentHistory.unavailable(account)
      end
    rescue PaymentApi::Error => err
      Rails.logger.warn("failed to get payment history: ", err)
      PaymentHistory.unavailable(account, err:)
    end

    usage = @collect_service_usage.run(account)
    BillingSummary.new(account:, payment_method:, payment_history:, usage:)
  end
end

# app/lib/payment_api.rb
class PaymentApi
  def initialize
    @client = SomeExternalPaymentApiClient.new
  end

  if Env.test?
    def self.new(failures: {})
      Mock::PaymentApi.new(failures:)
    end
  end

  # ...

  # def get_payment_history(account:, last:)
  #   @client.history(customer_id: account.public_id, history_count: last, order: :latest)
  # end
end

class Api::BillingController < ApplicationController
  def setup(build_billing_summary: Billing::BuildSummary.new)
    @build_billing_summary = build_billing_summary
  end

  if Env.test?
    def setup
      case test_context
      in 'default'
        super()
      in 'payment_history_error'
        super(build_billing_summary: Billing::BuildSummary.new(mode: :payment_history_error))
      end
    end
  end

  def summary
    summary = @build_billing_summary.run(account: signin_account)
    render json: serialize(summary)
  end
end

class ApplicationController
  before_action :setup
  def setup; end

  if Env.test?
    def test_context
      request.headers['App-Test-Context'] || 'default'
    end
  end
end
```

深い階層にいるやつの挙動をあとからカスタマイズしたくなったら、そこにいたるまでのツリーを全部いじらないといけないのが大変。
逆にもうカスタマイズが不要になって実は使われてないのに残り続けるとかもありえる。
なるべくこういうことしないで済むならそうしたいが、どうすれば。結局依存関係を飛び越えてテスト中に邪魔なやつを全部モックする方が簡単？　うーん。

ここで考えてるような工夫は、そもそもテスト時に依存は全部モックにして対象のクラスを完全に単体でテストする方針なら問題にはならないんだよな。
直接依存するクラスだけを気にすれば済むから。
その代わり各クラスが実際に協調して正しく動くことの担保は別途欲しくなるし、 Ruby だとモックと実際のクラスにずれがあっても見逃したりしうる。
また E2E テストの時にも困る。

一方で上記のようなことをするなら、テストモードのテストも欲しくなる。

もしくはアプリケーションコード内でのカスタマイズはなし？

- テスト時にはデフォルトでモックされるが、成功ケースのみ提供
- 失敗やイレギュラーケースをテストしたい時には、間接的な依存先についても知った上でそれを外からカスタマイズする

もしくはテスト時に引き起こせるパターンをグローバルに一覧化して、それを指定する？　そうするとクラス階層感で内部を隠蔽しつつ情報を渡してくような手間がなくなる。
でもこれで全部網羅するのは現実的じゃない気がする...

```ruby
class PaymentApi
  if Env.test?
    def self.new
      if Env.test_context.include?(:fail_to_payment_history_by_network_error)
        # ...
      else
        # ...
      end
    end
  end
end
```

うーん、でも例えば context に含める期待挙動を「ユーザー目線のストーリーで書く」ルールにして内部実装とは切り離した上で、その期待されるパターンを実現するために必要なクラスが自身の挙動を調整する、とかなら何とかなる？
