+++
date = "2019-06-30T10:18:03+09:00"
description = ""
draft = true
tags = ["ruby", "rails"]
title = "Rails 開発で意識していること"
updated = "2019-06-30T10:18:03+09:00"
+++

ふと思いたち、普段 Rails で開発する際に意識している諸々を文章化しておきます。
あくまで自分の開発経験に基づくものなので、以下を前提とします:

- 中規模なアプリ (テーブル数 100以下)
- 小規模なチーム (開発者が5名以下)
- そもそもなぜ Rails なのかは考えない (そこは動かせないものとする)

## 要点

- DSL とロジックを分ける
    - Controller, Model など Rails が提供してくれるのは宣言的にかける DSLに近い
    - DSL はなるべくテスト不要に、ロジックはテスタブルに
    - → Controller も Model も薄く
- 責務の分離と依存の明示
    - 暗黙的な依存をなくし、テスタビリティを確保
    - テストしやすさは時にテストそのものよりも大事

### DSL とロジックを分ける

コントローラやモデルなど、フレームワークに沿って書くコードは基本的に DSL だと言えます。
これらは必要な機能を宣言的に記述できるという意味で、極端に言えば YAML などの設定ファイルを書くのに近い側面があります。

```ruby
class User < ApplicationRecord
  # User は 0 個以上の Post を持つ。
  has_many :posts, dependent: :destroy

  # name は必須項目であり、最大文字数は30。
  # 実際のバリデーション処理を書く必要はない。
  validates :name, presence: true, length: { maximum: 30 }
end

# TODO: Controller もある方がいいか
```

そしてこの DSL による記述が正しく機能する事に関しては Rails が責任を持ちます。
そういう意味で、個人的にはこれらの宣言、例えばモデルのバリデーションが期待通りに機能するか、といったテストは不要 (であるべき) だと考えています。そこに責任を持つのはフレームワークの方であり、使用者ではないからです。
とはいえ、実際のユースケースに沿ったテストを書いていれば、間接的にバリデーションのテストを含む事も多いでしょう。
それで充分だし、逆に「名前は必須であること」だけをチェックするようなテストは不要だと思います。

```ruby
it "requires name" do
  user = User.new(name: nil)
  user.valid?
  assert { user.errors[:name].present? }
end
```

感覚的には、これは`validates :name, presence: true`を 2 回書いてるだけのような気がします。
バリデーションのルールが変わる度にこのテストを修正する事になるので、
いわゆるダブルチェックくらいの意義しかないと感じます。

#### ビジネスロジックの分離

しかし、Rails の DSL を書くだけで完成するアプリケーションは多くないでしょう。
大抵はそのアプリケーションに固有のビジネスロジックを実装する必要があるはずです。
そしてこちらに責任を持つのはフレームワークではなく私達自身となります。
そのためビジネスロジックは注意深く DSL と分離し、独立して保守・テストできるようにしておくべきでしょう。
よく言うファットなコントローラがよろしくない理由もこれで、
コントローラの DSL 内にビジネスロジックが混ざっているとそれらを独立してテストする事が難しくなります。
そのため、ビジネスロジックは専用のレイヤーを設けて隔離するのが無難です。

自分は同じ理由でモデルもなるべく薄くある方がいい (DSL 以外を持ち込まない方がいい) と考えています。
これは Rails におけるモデルをどう捉えるかにもよるのですが、
個人的には「モデル == RDB のテーブル・レコードに紐づくクラス」とだけ割り切る方がシンプルで良いと感じています。
実際 ActiveRecord となるモデルはその時点で DB アクセスに関する様々な責務を負っているので、
なるべくそれだけに徹するのが良いのではないでしょうか。

逆にモデルをドメインモデルとして捉え、ビジネスロジックを集約するパターンもあるようです。
この場合は ActiveRecord とはならない (`ApplicationRecord`を継承しない) モデルも多数出現する事になるのでしょうか？  
自分は単純に、
`app/models`内の (抽象クラスを除く) 全クラスが DB のテーブルに 1:1 対応しているとわかりやすくて良いと感じるので、
ビジネスロジックには別のレイヤーを設けるようにしています。
端的にいうと、モデルはデータの入れ物くらいの扱いになっています。

- TODO: ドメインモデル貧血症との関係
- oop vs functional??
- Rails 自体の方針は？

### 責務の分離と依存の明示

これは Rails に限りませんが、ビジネスロジックをモジュール化する際は責務の境界線をハッキリさせる事と、依存を明示的にして差し替え可能にする事を意識しています。
依存を差し替え可能にするのはもちろんテストのためですが、そのモジュールが何に依存しているかを明示する事で責務を把握しやすくする意味もあります。
雑に「モジュール」という言葉を使いましたが、これは Ruby の`module`の話ではなく、
コードとしてはクラスで実装するのがシンプルでわかりやすいです。

- 依存関係はコンストラクタで受け取る。
- 状態は持たない。

```ruby
class UserSurveyDelivery
  def self.create
    new(mailer: UserSurveyMailer)
  end

  def initialize(mailer:)
    @mailer = mailer
  end

  def deliver_surveys(registered_at:)
    select_users(registered_at).find_each do |user|
      @mailer.survey(user).deliver_later
    end
  end

  # ...
end
```

このサンプルみたいな雰囲気でユースケースごとにロジックを実装したクラスのレイヤーを設けます。
大体はこれを「サービス」と読んで`app/services`内に置きますが、もっと良い名前ないかなとよく思います。
詳細は後述します。

View の Helper や Concern など、 Rails は割と Mix-in を使うけど、個人的に Mix-in として機能をモジュール化するのは好きじゃない。これも後述。

## Model

## Service

## Controller

## その他

DB, テスト、misc

