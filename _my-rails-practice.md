+++
date = "2019-06-30T10:18:03+09:00"
description = ""
draft = true
tags = ["ruby", "rails"]
title = "Rails 開発で意識していること"
updated = "2019-06-30T10:18:03+09:00"
+++

# XXX

設計力アピールの意味も込めて普段 Rails 開発で考えてることをまとめてみようと思ったけど、
めっちゃいいスライドがあった。

https://speakerdeck.com/yasaichi/what-is-ruby-on-rails-and-how-to-deal-with-it

これだけちゃんとまとまってるの見るとやる気なくす。どのくらいの時間で作れちゃうんだろう。
要点に書いてるのもまあこういう人達には当たり前の話しだしこんな文量さいて書くことでもない？
モデルが複数のユースケース担うと辛いというのもその通りでよく言語化できたなー。
現状ではとりあえずユースケース用の層を作る方式を取ってる、てだけだし。
まあ最悪テストしやすければ良いじゃんという思想をさらっとまとめるくらいにする？

---

- Rails 開発で考えるべき事の基本は上記スライドによくまとまってる
- 拡張性やメンテナンス性に関する Rails の辛み解消法をフレームワーク化すると Hanami になりそう
- ひとまず Rails の上で頑張るには、DSLとロジックの分離、責務の切り分け、テスタビリティの確保あたりが大事では
- やはりコンパイラの静的チェックほしい..

---

ふと思いたち、普段 Rails で開発する際に意識している諸々を文章化しておきます。
あくまで自分の開発経験に基づくものなので、以下を前提とします:

- 中規模なアプリ (テーブル数 100以下)
- 小規模なチーム (開発者が5名前後)
- そもそもなぜ Rails なのかは考えない (そこは動かせないものとする)
- 特に客観的なデータに基づいた話ではない

## 要点

最初に、普段意識している事のおおもとの目的というか前提を確認したいので、まずは Rails に限らない抽象的な話から始めます。  
例えば適切な命名なり責務の分割なり、コードを書く上で気をつけるべき点は山程あるわけですが、
そもそもなぜそういった種々のプラクティスが生まれ必要とされ、たかがコードの記述に試行錯誤するのかと言えば、
それはきっと**変化に強いコードを書く**ためだと要約できるように思います。  

プロジェクトのフェーズや性質にもよるでしょうが、
一般にソフトウェアは要件や状況に応じて変わり続けるものであり
 (そのための「ソフト」ウェアであるはず)、
一度書けばそれでおしまい、とは普通いきません。
つまり「変化に強い」とは将来の拡張が容易で、そのようなソフトウェアの本分を全うしやすいコードを指すとします。
これは簡潔に言うと、コードは固定された作品の類ではなく、書かれた後でも書き換えやすい・修正しやすい状態であるべきだという事になります。
ではどんなコードなら修正しやすいかを考えてみると、以下のような性質が求められるのではないでしょうか。

-  読みやすい。
    - 既存の挙動を把握しやすい。
    - 修正すべき箇所を特定しやすい。
- 動作検証すなわちテストを自動化しやすい。
    - 何をテストすべきか、どこをテストすべきかが明確である。
    - テストに必要なセットアップが少ない。

修正するためにはまず既存のコードを読まなければいけないし、
修正する際には自動テストがあれば、期待する振る舞いとなるかを将来に渡って繰り返し検証できるからです。

そしてこれらのために重要になるのが、コードを適切に構造化することだと考えます。  
これはマクロ的にはモジュール切り分けの問題です。
複雑な要件を実現するための巨大なコードを一気に構築・把握・修正するのは難易度が高いため、
大きな要件は複数の独立した小さな機能 (モジュール) に分解し、その組み合わせとして実現するのが一般的だと思います。
ここで各モジュールの独立性が大事なのは、その方が個別に修正・テストでき、上述した目指すべき性質を得やすいからです。
よって要件をモジュールに切り分ける際には、

- モジュールの担う責務 (=テスト項目) を明確にする。
- 1つの責務を複数のモジュールに重複して負わせない。
- 依存するモジュールは実行時に差し替え可能にする。

といった点が基本的な原則になると思います。
3つ目はテストを容易にするためで、
これを可能にするためにモジュールは他モジュールのインターフェイスにのみ依存するように気をつけます。

またミクロ的には誤読の可能性を出来る限り排除した、意図の明確なコードを書く意識の問題です。
適切な命名、用語や構文の統一、コメントによる補助などを駆使して、
「なぜこの書き方なのか」に対して疑問を抱かせないコードなら、読み手はロジックの理解に集中できるはずです。
例えば同じようなものを指す単語が複数あると、それらが微妙に違うから名前も違うのか、単に統一されていないだけなのかを逐一判断しなければなりません。
ソースコードは機械ではなく人間が読むためのものである、という点を忘れないようにすべきでしょう 
(コードは機械向けのプログラム生成を容易にするための道具であり、コード自体を読むのは常に人間)。

中々ふわっとした話ですが、
どんなフレームワークを使って何を目的としたソフトウェアを書くにしても、自分は以上のような方針を意識して取り組むと思います
 (書き捨てのスクリプトでもない限り)。
でここまではただの前提で、じゃあそれらの方針をどんな風に Rails での開発に適用していくのか、というのを以降では考えます。

またこれも Rails に限りませんが、コードを書く際にはその言語や使用するフレームワークの慣習・規約に則る事も大切です。
無意味にオリジナリティを加えるのは読み手に負荷を与えるだけだからです。
しかし時にはその手の慣習や規約が、上述した方針と相容れない事もあります。そういう場合、自分は基本的に後者を優先します。

(TODO: SOLID, YAGNI, Clean Architecture,ナブコフの置換原則などなど、有名なやつは名前だけでも出すべき？
実際↑のような事を一から自分で考えたわけじゃないはず
)

## 要点 (old)

まずは Rails に限らない抽象的な話から始めると、
例えば適切な命名なり責務の分割なり、コードを書く上で気をつけるべき点はたくさんあるわけですが、
そもそもなぜそういった諸々をあれこれ試行錯誤するのかといえば、
それはきっと**変化に強いコードを書く**ためだと要約できるように思います。  
プロジェクトのフェーズや性質にもよるでしょうが、
一般にソフトウェアは要件や状況に応じて変わり続ける (べき) ものであり
  (それこそがソフトウェアという名の意味であり存在理由のはず)、
「変化に強い」とはそういった拡張が容易である事を指します。
となれば、そのためには以下の2点が重要になってくると思います:

- 修正がしやすい事
- テストが書きやすい事

修正が容易であれば要件の変化に追従しやすいし、
自動テストがあれば修正の度に数多くの動作検証を繰り返し行えます。
しかしテストだってコードですから、テスト自体もまた「変化に強い」必要があるでしょう。
そのため大切なのはテストの存在というより、テストが容易な構造の方だと考えています。

XXX: 
まず「書き直しやすい」(=修正しやすい =変化に強い) があり、そのために「読みやすい」と「テストが書きやすい」があるか。
またちょっと再構成が必要。

修正やテスト
要はコードを繰り返し読まれ書き直されていくものと考える以上、
読むコストと書き直すコストを低くする事が大切になるはずです。

> - 修正がしやすい事
>     - 要件の変化に追従するため。
>         - 変更すべき箇所が特定しやすい。
>         - 変更による影響が予測しやすい。
> - テストが書きやすい事
>     - 動作検証を繰り返し行うため。
> コードは繰り返し読まれ書き直されていくものと考える以上、
> 読むコストと書き直すコストを低くする事を目指すべきでしょう。
> (?また特に非技術者には誤解されがちですが、ソースコードは機械ではなく人間が読むためのものである点も忘れないべきでしょう。?)

では、読みやすく書き直しやすいコードを記述・維持していくには何に気をつけるべきでしょうか？

- 意図の明確なコードを書く。
    - 誤読の余地を限りなく減らす。
    - 名前、処理の手順、構文といったあらゆる側面で「なぜその書き方を選んだか」に疑問の余地を残さない。
- 複数の責務は混ぜずに境界線を引く。
    - コードの担う責務 (テスト項目) を明確にする。
    - 1つの責務を複数のモジュールに重複して負わせない。
    - (依存の差し替え)

だいぶふわっとした話ですが、
以上はどんなフレームワークを使って何を目的としたソフトウェアを書くにしても考えるべき方針ではないかと思います。
で、今回は Ruby on Rails による Web アプリケーションの作成についてとなるので、
上記に加えて Ruby と Rails の規約・慣習には可能な限り則るという点も大切になります。
ただしもしも上述した方針と Rails の規約に相容れない点がある場合は、自分は基本的に前者を優先します。

以降では、 Rails を書く上でこれらの philosophy? をどう適用していくかを考えていきます。

## ??

- DSL とビジネスロジックを分ける


- なるべく Mix-in ではなくプレーンなクラスを使う
- コントローラにビジネスロジックを置かない
- モデルにも詰め込みすぎない
- モデルに分類しにくいロジック用の層を1つ設ける

### DSL とロジックを分ける

Rails ではコントローラによるリクエストのハンドリングや、モデルのバリデーションや関連定義といった機能を簡潔に書ける仕組みが用意されています。フレームワークに沿って書くこういったコードは、基本的に DSL と言えると思います。
これらは必要な機能を宣言的に記述できるという意味で、極端に言えば YAML などの設定ファイルを書くのに近い側面があります。

```ruby
class User < ApplicationRecord
  # User は 0 個以上の Post を持つ。
  has_many :posts, dependent: :destroy

  # name は必須項目であり、最大文字数は30。
  # 実際のバリデーション処理を書く必要はない。
  validates :name, presence: true, length: { maximum: 30 }
end

# TODO: Controller もある方がいいか
```

そしてこの DSL による記述が正しく機能する事に関しては Rails が責任を持ちます。
そういう意味で、これらの機能を直接的に確かめるテストは不要だと考えています (後述)。

一方で、Rails の DSL を書くだけで完成するアプリケーションは多くないでしょう。
大抵はそのアプリケーションに固有のビジネスロジックを実装する必要があるはずです。
そしてこちらに責任を持つのは、フレームワークではなくアプリを開発する私達自身となります。
当然ロジックはメンテナブルであるべきだし、ユースケースに沿ったテストも必要です。

従って、フレームワークに沿って記述する DSL とビジネスロジックは、安易に混ぜ込まず分離する方が良いでしょう。
DSL 部分はモックに差し替えにくいので、その中にロジックが埋め込まれているとテストがしづらいし、責任範囲も曖昧になります。
特に副作用満載のコントローラがロジックを持ってしまうと非常にテストしにくいです。
Fat Controller がアンチパターンと呼ばれる所以の 1 つですね。

するとコントローラではなくモデルにロジックを寄せようという事になりがちですが、
何でもモデルに詰め込むと今度は Fat なモデルが出来上がります。
例えば複数の会社情報を管理するアプリケーションがあった時、
会社情報は`Company`のようなモデルで表現すれば良いとして、「会社検索」のような機能はどこに置くべきでしょうか？
`Company`の特異メソッドとして実装し、`Comapny.search(params)`のように使えるようにするのは一見良さそうです。
実際 ActiveRecord でもある`Company`がレコードの作成や削除を担うのと同じように、データの検索も担うのは自然でもあります。
しかしこの調子で会社に関連する様々な処理 (TODO: 例が欲しい) を`Company`の特異メソッドやインスタンスメソッドとして実装していくと、
`Company`クラスはあっという間に巨大化します。それらが1つのクラスとしてまとまっている事に意義があるならまだしも、
実際にはどれも「会社に関係する」というだけで本質的には独立した様々な処理が不必要に 1 ファイルにまとめられている、という状況になりがちです。
Rails の Concern という仕組み (ちょっとリッチな Mix-in) を使えば巨大化したクラスを複数ファイルに分割する事もできますが、
これは後述する理由で良い方法とは思えません。
そもそもわざわざモデルクラスに全てを詰め込まず、「会社検索」のような個別の機能 -- モデルが主語となるのではなく、モデルを登場人物として扱うような一続きの処理 -- は、それぞれ独立して実装・管理する方が見通しが良いのではないでしょうか。
というわけでそのためのレイヤー、すなわちビジネスロジックをユースケースごとにクラス化して実装するレイヤーを設けるのも (たぶん) 一般的でしょう。これはサービス層と呼ばれる事が多いように感じます。
自分もだいたいこの層を設けていて、`app/services`や`app/lib`のようなディレクトリを作ってそこに詰め込んでいます。

- TODO: そもそもモデルとは？
  単にレコードにマッピングされるだけの存在なのか？
  例えばユースケースをオブジェクト化したものがまさしくモデルと呼ばれたりしなかったっけ？

アプリのコアであるビジネスロジックをもともと Rails には存在しない層に置くもう1つの理由は、
コア部分をなるべくフレームワークと疎結合に保つためです。
サービス層には何も継承しないプレーンなクラスを置くようにします。
実際にはサービス内で ActiveRecord や ActiveJob といった Rails の機能を使う事にはなりますが、
それらを差し替え可能な依存関係とする事で、ロジックとの境界線を引きやすくなります。

### ビジネスロジックの分離

(別セクションの方がいいか)

しかし、Rails の DSL を書くだけで完成するアプリケーションは多くないでしょう。
大抵はそのアプリケーションに固有のビジネスロジックを実装する必要があるはずです。
そしてこちらに責任を持つのはフレームワークではなく私達自身となります。
そのためビジネスロジックは注意深く DSL と分離し、独立して保守・テストできるようにしておくべきでしょう。
よく言うファットなコントローラがよろしくない理由もこれで、
コントローラの DSL 内にビジネスロジックが混ざっているとそれらを独立してテストする事が難しくなります。
そのため、ビジネスロジックは専用のレイヤーを設けて隔離するのが無難です。

自分は同じ理由でモデルもなるべく薄くある方がいい (DSL 以外を持ち込まない方がいい) と考えています。
これは Rails におけるモデルをどう捉えるかにもよるのですが、
個人的には「モデル == RDB のテーブル・レコードに紐づくクラス」とだけ割り切る方がシンプルで良いと感じています。
実際 ActiveRecord となるモデルはその時点で DB アクセスに関する様々な責務を負っているので、
なるべくそれだけに徹するのが良いのではないでしょうか。

逆にモデルをドメインモデルとして捉え、ビジネスロジックを集約するパターンもあるようです。
この場合は ActiveRecord とはならない (`ApplicationRecord`を継承しない) モデルも多数出現する事になるのでしょうか？  
自分は単純に、
`app/models`内の (抽象クラスを除く) 全クラスが DB のテーブルに 1:1 対応しているとわかりやすくて良いと感じるので、
ビジネスロジックには別のレイヤーを設けるようにしています。

- TODO: Rails 自体の方針は？

#### ドメインモデル貧血症？

- サービスレイヤで手続き的なコードを書けば充分なのは、扱うドメインの複雑さがその程度だから？
- でも例えば GitHub の Issue みたいなチケットアプリがあったとして、`Issue.open`のようにオブジェクトが処理を持つよりも、
  `open(issue)`みたいに処理とデータを分ける方が好みかも。例えば`open`や`close`の処理はそれぞれ独立してるのに、
  1つのインターフェイスとしてまとまって提供される必要はあるのか？ モジュールとしてまとまってれば充分。
- かといって、`Issue`がオープンかどうかを知るのに`issue.closed_at.nil?`のようなチェックはしたくない。
  モデルがインターフェイスを提供して`issue.open?`のように書けるべき。責務の分離でもあり可読性の問題でもある。
  モデルに持たせるべきかどうかの判断基準は？

`service`という名前だと何かを処理する系を置く場所っぽいので、`lib`くらい雑な名前にして DB に紐付かないオブジェクトも置きやすくする？
そいつらが ActiveModel を使うなら、`app/models`にある方がきれいなのでは..

### 責務の分離と依存の明示

これは Rails に限りませんが、ビジネスロジックをモジュール化する際は責務の境界線をハッキリさせる事と、依存を明示的にして差し替え可能にする事を意識しています。
依存を差し替え可能にするのはもちろんテストのためですが、そのモジュールが何に依存しているかを明示する事で責務を把握しやすくする意味もあります。
雑に「モジュール」という言葉を使いましたが、これは Ruby の`module`の話ではなく、
コードとしてはクラスで実装するのがシンプルでわかりやすいです。

- 依存関係はコンストラクタで受け取る。
- 状態は持たない。

```ruby
class UserSurveyDelivery
  def self.create
    new(mailer: UserSurveyMailer)
  end

  def initialize(mailer:)
    @mailer = mailer
  end

  def deliver_surveys(registered_at:)
    select_users(registered_at).find_each do |user|
      @mailer.survey(user).deliver_later
    end
  end

  # ...
end
```

このサンプルみたいな雰囲気でユースケースごとにロジックを実装したクラスのレイヤーを設けます。
大体はこれを「サービス」と読んで`app/services`内に置きますが、もっと良い名前ないかなとよく思います。
詳細は後述します。

View の Helper や Concern など、 Rails は割と Mix-in を使うけど、個人的に Mix-in として機能をモジュール化するのは好きじゃない。これも後述。

## Model

## Service

## Controller

## テスト


(テストについてはテストのセクションで書く方がいいか)

そういう意味で、個人的にはこれらの宣言、例えばモデルのバリデーションが期待通りに機能するか、といったテストは不要 (であるべき) だと考えています。そこに責任を持つのはフレームワークの方であり、使用者ではないからです。
とはいえ、実際のユースケースに沿ったテストを書いていれば、間接的にバリデーションのテストを含む事も多いでしょう。
それで充分だし、逆に「名前は必須であること」だけをチェックするようなテストは不要だと思います。

```ruby
it "requires name" do
  user = User.new(name: nil)
  user.valid?
  assert { user.errors[:name].present? }
end
```

しかしこういうテストはバリデーションのルールが変わる度に修正する事になるので、
書いたコードをダブルチェックしているだけのような感覚になります。


コントローラに関しては、E2Eで全体をテストするのと、単体テストでコントローラ内のロジックだけテストしたい。
でも例えば`render status: :not_found`が実際に 404 を返すか、といったテストはいらない。

## その他

DB, テスト、misc

